_G._DEBUG = true
_G.httplib = (function() local ffi = require("ffi") local steam_http_raw = ffi.cast("uint32_t**", ffi.cast("char**", ffi.cast("char*", memory.find_pattern("client.dll", "B9 ? ? ? ? E8 ? ? ? ? 83 3D ? ? ? ? ? 0F 84")) + 1)[0] + 48)[0] or error("steam_http error") local steam_http_ptr = ffi.cast("void***", steam_http_raw) or error("steam_http_ptr error") local steam_http = steam_http_ptr[0] or error("steam_http_ptr was null")  local function __thiscall(func, this)  	return function(...) 		return func(this, ...) 	end end  local createHTTPRequest_native = __thiscall(ffi.cast(ffi.typeof("uint32_t(__thiscall*)(void*, uint32_t, const char*)"), steam_http[0]), steam_http_raw) local sendHTTPRequest_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, uint64_t)"), steam_http[5]), steam_http_raw) local getHTTPResponseHeaderSize_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, const char*, uint32_t*)"), steam_http[9]), steam_http_raw) local getHTTPResponseHeaderValue_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, const char*, char*, uint32_t)"), steam_http[10]), steam_http_raw) local getHTTPResponseBodySize_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, uint32_t*)"), steam_http[11]), steam_http_raw) local getHTTPBodyData_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, char*, uint32_t)"), steam_http[12]), steam_http_raw) local setHTTPHeaderValue_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, const char*, const char*)"), steam_http[3]), steam_http_raw) local setHTTPRequestParam_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, const char*, const char*)"), steam_http[4]), steam_http_raw) local setHTTPUserAgent_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t, const char*)"), steam_http[21]), steam_http_raw) local setHTTPRequestRaw_native = __thiscall(ffi.cast("bool(__thiscall*)(void*, uint32_t, const char*, const char*, uint32_t)", steam_http[16]), steam_http_raw) local releaseHTTPRequest_native = __thiscall(ffi.cast(ffi.typeof("bool(__thiscall*)(void*, uint32_t)"), steam_http[14]), steam_http_raw)  local requests = {} callbacks.add(e_callbacks.PAINT, function () 	for _, instance in ipairs(requests) do 		if global_vars.cur_time() - instance.ls > instance.task_interval then 			instance:_process_tasks() 			instance.ls = global_vars.cur_time() 		end 	end end)  local request = {} local request_mt = {__index = request} function request.new(requestHandle, requestAddress, callbackFunction) 	return setmetatable({handle = requestHandle, url = requestAddress, callback = callbackFunction, ticks = 0}, request_mt) end local data = {} local data_mt = {__index = data} function data.new(state, body, headers) 	return setmetatable({status = state, body = body, headers = headers}, data_mt) end function data:success() 	return self.status == 200 end  local http = {state = {ok = 200, no_response = 204, timed_out = 408, unknown = 0}} local http_mt = {__index = http} function http.new(task) 	task = task or {} 	local instance = setmetatable({requests = {}, task_interval = task.task_interval or 0.3, enable_debug = task.debug or false, timeout = task.timeout or 10, ls = global_vars.cur_time()}, http_mt) 	table.insert(requests, instance) 	return instance end local method_t = {['get'] = 1, ['head'] = 2, ['post'] = 3, ['put'] = 4, ['delete'] = 5, ['options'] = 6, ['patch'] = 7} function http:request(method, url, options, callback) 	if type(options) == "function" and callback == nil then 		callback = options 		options = {} 	end 	options = options or {} 	local method_num = method_t[tostring(method):lower()] 	local reqHandle = createHTTPRequest_native(method_num, url) 	local content_type = "application/text" 	if type(options.headers) == "table" then 		for name, value in pairs(options.headers) do 			name = tostring(name) 			value = tostring(value) 			if name:lower() == "content-type" then 				content_type = value 			end 			setHTTPHeaderValue_native(reqHandle, name, value) 		end 	end 	if type(options.body) == "string" then 		local len = options.body:len() 		setHTTPRequestRaw_native(reqHandle, content_type, ffi.cast("unsigned char*", options.body), len) 	end 	if type(options.params) == "table" then 		for k, v in pairs(options.params) do 			setHTTPRequestParam_native(reqHandle, k, v) 		end 	end 	if type(options.user_agent_info) == "string" then 		setHTTPUserAgent_native(reqHandle, options.user_agent_info) 	end 	if not sendHTTPRequest_native(reqHandle, 0) then 		return 	end 	local reqInstance = request.new(reqHandle, url, callback) 	self:_debug("[HTTP] New %s request to: %s", method:upper(), url) 	table.insert(self.requests, reqInstance) end function http:get(url, callback) 	local reqHandle = createHTTPRequest_native(1, url) 	if not sendHTTPRequest_native(reqHandle, 0) then 		return 	end 	local reqInstance = request.new(reqHandle, url, callback) 	self:_debug("[HTTP] New GET request to: %s", url) 	table.insert(self.requests, reqInstance) end function http:post(url, params, callback) 	local reqHandle = createHTTPRequest_native(3, url) 	for k, v in pairs(params) do 		setHTTPRequestParam_native(reqHandle, k, v) 	end 	if not sendHTTPRequest_native(reqHandle, 0) then 		return 	end 	local reqInstance = request.new(reqHandle, url, callback) 	self:_debug("[HTTP] New POST request to: %s", url) 	table.insert(self.requests, reqInstance) end function http:_process_tasks() 	for k, v in ipairs(self.requests) do 		local data_ptr = ffi.new("uint32_t[1]") 		self:_debug("[HTTP] Processing request #%s", k) 		if getHTTPResponseBodySize_native(v.handle, data_ptr) then 			local reqData = data_ptr[0] 			if reqData > 0 then 				local strBuffer = ffi.new("char[?]", reqData) 				if getHTTPBodyData_native(v.handle, strBuffer, reqData) then 					self:_debug("[HTTP] Request #%s finished. Invoking callback.", k) 					v.callback(data.new(http.state.ok, ffi.string(strBuffer, reqData), setmetatable({}, {__index = function(tbl, val) return http._get_header(v, val) end}))) 					table.remove(self.requests, k) 					releaseHTTPRequest_native(v.handle) 				end 			else 				v.callback(data.new(http.state.no_response, nil, {})) 				table.remove(self.requests, k) 				releaseHTTPRequest_native(v.handle) 			end 		end 		local timeoutCheck = v.ticks + 1; 		if timeoutCheck >= self.timeout then 			v.callback(data.new(http.state.timed_out, nil, {})) 			table.remove(self.requests, k) 			releaseHTTPRequest_native(v.handle) 		else 			v.ticks = timeoutCheck 		end 	end end function http:_debug(...) 	if self.enable_debug then 		client.log(string.format(...)) 	end end function http._get_header(reqInstance, query) 	local data_ptr = ffi.new("uint32_t[1]") 	if getHTTPResponseHeaderSize_native(reqInstance.handle, query, data_ptr) then 		local reqData = data_ptr[0] 		local strBuffer = ffi.new("char[?]", reqData) 		if getHTTPResponseHeaderValue_native(reqInstance.handle, query, strBuffer, reqData) then 			return ffi.string(strBuffer, reqData) 		end 	end 	return nil end function http._bind(class, funcName) 	return function(...) 		return class[funcName](class, ...) 	end end  return http end)()
_G.json = (function() local json = { _version = "0.1.2" }  local encode local escape_char_map = {   [ "\\" ] = "\\",   [ "\"" ] = "\"",   [ "\b" ] = "b",   [ "\f" ] = "f",   [ "\n" ] = "n",   [ "\r" ] = "r",   [ "\t" ] = "t", }  local escape_char_map_inv = { [ "/" ] = "/" } for k, v in pairs(escape_char_map) do   escape_char_map_inv[v] = k end  local function escape_char(c)   return "\\" .. (escape_char_map[c] or string.format("u%04x", c:byte())) end  local function encode_nil(val)   return "null" end  local function encode_table(val, stack)   local res = {}   stack = stack or {} if stack[val] then error("circular reference") end stack[val] = true if rawget(val, 1) ~= nil or next(val) == nil then  local n = 0  for k in pairs(val) do    if type(k) ~= "number" then   error("invalid table: mixed or invalid key types")    end    n = n + 1  end  if n ~= #val then    error("invalid table: sparse array")  end  for i, v in ipairs(val) do    table.insert(res, encode(v, stack))  end  stack[val] = nil  return "[" .. table.concat(res, ",") .. "]" else  for k, v in pairs(val) do    if type(k) ~= "string" then   error("invalid table: mixed or invalid key types")    end    table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))  end  stack[val] = nil  return "{" .. table.concat(res, ",") .. "}"   end end  local function encode_string(val)   return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"' end  local function encode_number(val)   if val ~= val or val <= -math.huge or val >= math.huge then  error("unexpected number value '" .. tostring(val) .. "'")   end   return string.format("%.14g", val) end  local type_func_map = {   [ "nil"  ] = encode_nil,   [ "table"   ] = encode_table,   [ "string"  ] = encode_string,   [ "number"  ] = encode_number,   [ "boolean" ] = tostring, }  encode = function(val, stack)   local t = type(val)   local f = type_func_map[t]   if f then  return f(val, stack)   end   error("unexpected type '" .. t .. "'") end  function json.encode(val)   return ( encode(val) ) end  local parse local function create_set(...)   local res = {}   for i = 1, select("#", ...) do  res[ select(i, ...) ] = true   end   return res end  local space_chars   = create_set(" ", "\t", "\r", "\n") local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",") local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u") local literals   = create_set("true", "false", "null")  local literal_map = {   [ "true"  ] = true,   [ "false" ] = false,   [ "null"  ] = nil, }  local function next_char(str, idx, set, negate)   for i = idx, #str do  if set[str:sub(i, i)] ~= negate then    return i  end   end   return #str + 1 end  local function decode_error(str, idx, msg)   local line_count = 1   local col_count = 1   for i = 1, idx - 1 do  col_count = col_count + 1  if str:sub(i, i) == "\n" then    line_count = line_count + 1    col_count = 1  end   end   error( string.format("%s at line %d col %d", msg, line_count, col_count) ) end  local function codepoint_to_utf8(n)   local f = math.floor   if n <= 0x7f then  return string.char(n)   elseif n <= 0x7ff then  return string.char(f(n / 64) + 192, n % 64 + 128)   elseif n <= 0xffff then  return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)   elseif n <= 0x10ffff then  return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,      f(n % 4096 / 64) + 128, n % 64 + 128)   end   error( string.format("invalid unicode codepoint '%x'", n) ) end  local function parse_unicode_escape(s)   local n1 = tonumber( s:sub(1, 4),  16 )   local n2 = tonumber( s:sub(7, 10), 16 )   if n2 then  return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)   else  return codepoint_to_utf8(n1)   end end  local function parse_string(str, i)   local res = ""   local j = i + 1   local k = j while j <= #str do  local x = str:byte(j)   if x < 32 then    decode_error(str, j, "control character in string")   elseif x == 92 then  res = res .. str:sub(k, j - 1)    j = j + 1    local c = str:sub(j, j)    if c == "u" then   local hex = str:match("^[dD][89aAbB]%x%x\\u%x%x%x%x", j + 1)      or str:match("^%x%x%x%x", j + 1)      or decode_error(str, j - 1, "invalid unicode escape in string")   res = res .. parse_unicode_escape(hex)   j = j + #hex    else   if not escape_chars[c] then     decode_error(str, j - 1, "invalid escape char '" .. c .. "' in string")   end   res = res .. escape_char_map_inv[c]    end    k = j + 1   elseif x == 34 then  res = res .. str:sub(k, j - 1)    return res, j + 1  end   j = j + 1   end decode_error(str, i, "expected closing quote for string") end  local function parse_number(str, i)   local x = next_char(str, i, delim_chars)   local s = str:sub(i, x - 1)   local n = tonumber(s)   if not n then  decode_error(str, i, "invalid number '" .. s .. "'")   end   return n, x end  local function parse_literal(str, i)   local x = next_char(str, i, delim_chars)   local word = str:sub(i, x - 1)   if not literals[word] then  decode_error(str, i, "invalid literal '" .. word .. "'")   end   return literal_map[word], x end  local function parse_array(str, i)   local res = {}   local n = 1   i = i + 1   while 1 do  local x  i = next_char(str, i, space_chars, true)  if str:sub(i, i) == "]" then    i = i + 1    break  end  x, i = parse(str, i)  res[n] = x  n = n + 1  i = next_char(str, i, space_chars, true)  local chr = str:sub(i, i)  i = i + 1  if chr == "]" then break end  if chr ~= "," then decode_error(str, i, "expected ']' or ','") end   end   return res, i end  local function parse_object(str, i)   local res = {}   i = i + 1   while 1 do  local key, val  i = next_char(str, i, space_chars, true)  if str:sub(i, i) == "}" then    i = i + 1    break  end  if str:sub(i, i) ~= '"' then    decode_error(str, i, "expected string for key")  end  key, i = parse(str, i)  i = next_char(str, i, space_chars, true)  if str:sub(i, i) ~= ":" then    decode_error(str, i, "expected ':' after key")  end  i = next_char(str, i + 1, space_chars, true)  val, i = parse(str, i)  res[key] = val  i = next_char(str, i, space_chars, true)  local chr = str:sub(i, i)  i = i + 1  if chr == "}" then break end  if chr ~= "," then decode_error(str, i, "expected '}' or ','") end   end   return res, i end  local char_func_map = {   [ '"' ] = parse_string,   [ "0" ] = parse_number,   [ "1" ] = parse_number,   [ "2" ] = parse_number,   [ "3" ] = parse_number,   [ "4" ] = parse_number,   [ "5" ] = parse_number,   [ "6" ] = parse_number,   [ "7" ] = parse_number,   [ "8" ] = parse_number,   [ "9" ] = parse_number,   [ "-" ] = parse_number,   [ "t" ] = parse_literal,   [ "f" ] = parse_literal,   [ "n" ] = parse_literal,   [ "[" ] = parse_array,   [ "{" ] = parse_object, }  parse = function(str, idx)   local chr = str:sub(idx, idx)   local f = char_func_map[chr]   if f then  return f(str, idx)   end   decode_error(str, idx, "unexpected character '" .. chr .. "'") end  function json.parse(str)   if type(str) ~= "string" then  error("expected argument of type string, got " .. type(str))   end   local res, idx = parse(str, next_char(str, 1, space_chars, true))   idx = next_char(str, idx, space_chars, true)   if idx <= #str then  decode_error(str, idx, "trailing garbage")   end   return res end  return json end)()
_G.panorama = (function() local _INFO, cast, typeof, new, find_pattern, create_interface, api, safe_mode, _error, exception, exceptionCb, rawgetImpl, rawsetImpl, __thiscall, table_copy, vtable_bind, interface_ptr, vtable_entry, vtable_thunk, proc_bind, follow_call, v8js_args, v8js_function, is_array, nullptr, intbuf, panorama, vtable, DllImport, UIEngine, nativeIsValidPanelPointer, nativeGetLastDispatchedEventTargetPanel, nativeCompileRunScript, nativeRunScript, nativeGetV8GlobalContext, nativeGetIsolate, nativeGetParent, nativeGetID, nativeFindChildTraverse, nativeGetJavaScriptContextParent, nativeGetPanelContext, jsContexts, getJavaScriptContextParent, v8_dll, persistentTbl, Local, MaybeLocal, PersistentProxy_mt, Persistent, Value, Object, Array, Function, ObjectTemplate, FunctionTemplate, FunctionCallbackInfo, Primitive, Null, Undefined, Boolean, Number, Integer, String, Isolate, Context, HandleScope, TryCatch, Script, PanelInfo_t, CUtlVector_Constructor_t, panelList, panelArrayOffset, panelArray _INFO = { _VERSION = 1.3 } setmetatable(_INFO, { __call = function(self) return self._VERSION end, __tostring = function(self) return self._VERSION end }) if _G and not ffi then ffi = require("ffi") end do local _obj_0 = ffi cast, typeof, new = _obj_0.cast, _obj_0.typeof, _obj_0.new end find_pattern = function() return error("Unsupported provider (e.g. gamesense, neverlose)") end create_interface = function() return error("Unsupported provider (e.g. gamesense, neverlose)") end api = (_G == nil) and (info.fatality == nil and "ev0lve" or "fa7ality") or (file == nil and (GameEventManager == nil and (penetration == nil and (math_utils == nil and "primordial" or "legion") or "pandora") or "memesense") or "legendware") local _exp_0 = api if "ev0lve" == _exp_0 then find_pattern = utils.find_pattern create_interface = utils.find_interface elseif "fa7ality" == _exp_0 then find_pattern = utils.find_pattern create_interface = utils.find_interface elseif "primordial" == _exp_0 then find_pattern = memory.find_pattern create_interface = memory.create_interface elseif "memesense" == _exp_0 then find_pattern = Utils.PatternScan create_interface = Utils.CreateInterface elseif "legendware" == _exp_0 then find_pattern = utils.find_signature create_interface = utils.create_interface elseif "pandora" == _exp_0 then find_pattern = client.find_sig create_interface = client.create_interface elseif "legion" == _exp_0 then find_pattern = memory.find_pattern create_interface = memory.create_interface end safe_mode = xpcall and true or false _error = error if 1 + 2 == 3 then error = function(msg) for _, v in pairs(persistentTbl) do Persistent(v):disposeGlobal() end return _error(msg) end end exception = function(msg) return print("Caught exception in V8 HandleScope: ", tostring(msg)) end exceptionCb = function(msg) return print("Caught exception in V8 Function Callback: ", tostring(msg)) end rawgetImpl = function(tbl, key) local mtb = getmetatable(tbl) setmetatable(tbl, nil) local res = tbl[key] setmetatable(tbl, mtb) return res end rawsetImpl = function(tbl, key, value) local mtb = getmetatable(tbl) setmetatable(tbl, nil) tbl[key] = value return setmetatable(tbl, mtb) end if not rawget then rawget = rawgetImpl end if not rawset then rawset = rawsetImpl end __thiscall = function(func, this) return function(...) return func(this, ...) end end table_copy = function(t) local _tbl_0 = { } for k, v in pairs(t) do _tbl_0[k] = v end return _tbl_0 end vtable_bind = function(module, interface, index, typedef) local addr = cast("void***", create_interface(module, interface)) or error(interface .. " is nil.") return __thiscall(cast(typedef, addr[0][index]), addr) end interface_ptr = typeof("void***") vtable_entry = function(instance, i, ct) return cast(ct, cast(interface_ptr, instance)[0][i]) end vtable_thunk = function(i, ct) local t = typeof(ct) return function(instance, ...) return vtable_entry(instance, i, t)(instance, ...) end end proc_bind = (function() local fnGetProcAddress fnGetProcAddress = function() return error("Failed to load GetProcAddress") end local fnGetModuleHandle fnGetModuleHandle = function() return error("Failed to load GetModuleHandleA") end if ffi.C then ffi.cdef([[            uint32_t GetProcAddress(uint32_t, const char*); uint32_t GetModuleHandleA(const char*); ]]) fnGetProcAddress = ffi.C.GetProcAddress fnGetModuleHandle = ffi.C.GetModuleHandleA else fnGetProcAddress = cast("uint32_t(__stdcall*)(uint32_t, const char*)", cast("uint32_t**", cast("uint32_t", find_pattern("engine.dll", "FF 15 ? ? ? ? A3 ? ? ? ? EB 05")) + 2)[0][0]) fnGetModuleHandle = cast("uint32_t(__stdcall*)(const char*)", cast("uint32_t**", cast("uint32_t", find_pattern("engine.dll", "FF 15 ? ? ? ? 85 C0 74 0B")) + 2)[0][0]) end return function(module_name, function_name, typedef) return cast(typeof(typedef), fnGetProcAddress(fnGetModuleHandle(module_name), function_name)) end end)() follow_call = function(ptr) local insn = cast("uint8_t*", ptr) local _exp_1 = insn[0] if (0xE8 or 0xE9) == _exp_1 then return cast("uint32_t", insn + cast("int32_t*", insn + 1)[0] + 5) elseif 0xFF == _exp_1 then if insn[1] == 0x15 then return cast("uint32_t**", cast("const char*", ptr) + 2)[0][0] end else return ptr end end v8js_args = function(...) local argTbl = { ... } local iArgc = #argTbl local pArgv = new(("void*[%.f]"):format(iArgc)) for i = 1, iArgc do pArgv[i - 1] = Value:fromLua(argTbl[i]):getInternal() end return iArgc, pArgv end v8js_function = function(callbackFunction) return function(callbackInfo) callbackInfo = FunctionCallbackInfo(callbackInfo) local argTbl = { } local length = callbackInfo:length() if length > 0 then for i = 0, length - 1 do table.insert(argTbl, callbackInfo:get(i)) end end local val = nil if safe_mode then local status, ret = xpcall((function() return callbackFunction(unpack(argTbl)) end), exceptionCb) if status then val = ret end else val = callbackFunction(unpack(argTbl)) end return callbackInfo:setReturnValue(Value:fromLua(val):getInternal()) end end is_array = function(val) local i = 1 for _ in pairs(val) do if val[i] ~= nil then i = i + 1 else return false end end return i ~= 1 end nullptr = new("void*") intbuf = new("int[1]") panorama = { panelIDs = { } } do local _class_0 local _base_0 = { get = function(self, index, t) return __thiscall(cast(t, self.this[0][index]), self.this) end, getInstance = function(self) return self.this end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, ptr) self.this = cast("void***", ptr) end, __base = _base_0, __name = "vtable" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 vtable = _class_0 end do local _class_0 local _base_0 = { cache = { }, get = function(self, method, typedef) if not (self.cache[method]) then self.cache[method] = proc_bind(self.file, method, typedef) end return self.cache[method] end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, filename) self.file = filename end, __base = _base_0, __name = "DllImport" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 DllImport = _class_0 end UIEngine = vtable(vtable_bind("panorama.dll", "PanoramaUIEngine001", 11, "void*(__thiscall*)(void*)")()) nativeIsValidPanelPointer = UIEngine:get(36, "bool(__thiscall*)(void*,void const*)") nativeGetLastDispatchedEventTargetPanel = UIEngine:get(56, "void*(__thiscall*)(void*)") nativeCompileRunScript = UIEngine:get(113, "void****(__thiscall*)(void*,void*,char const*,char const*,int,int,bool)") nativeRunScript = __thiscall(cast(typeof("void*(__thiscall*)(void*,void*,void*,void*,int,bool)"), follow_call(find_pattern("panorama.dll", api == "legendware" and "E8 ? ? ? ? 8B 4C 24 10 FF 15 ?" or "E8 ? ? ? ? 8B 4C 24 10 FF 15 ? ? ? ?"))), UIEngine:getInstance()) nativeGetV8GlobalContext = UIEngine:get(123, "void*(__thiscall*)(void*)") nativeGetIsolate = UIEngine:get(129, "void*(__thiscall*)(void*)") nativeGetParent = vtable_thunk(25, "void*(__thiscall*)(void*)") nativeGetID = vtable_thunk(9, "const char*(__thiscall*)(void*)") nativeFindChildTraverse = vtable_thunk(40, "void*(__thiscall*)(void*,const char*)") nativeGetJavaScriptContextParent = vtable_thunk(218, "void*(__thiscall*)(void*)") nativeGetPanelContext = __thiscall(cast("void***(__thiscall*)(void*,void*)", follow_call(find_pattern("panorama.dll", "E8 ? ? ? ? 8B 00 85 C0 75 1B"))), UIEngine:getInstance()) jsContexts = { } getJavaScriptContextParent = function(panel) if jsContexts[panel] ~= nil then return jsContexts[panel] end jsContexts[panel] = nativeGetJavaScriptContextParent(panel) return jsContexts[panel] end v8_dll = DllImport("v8.dll") persistentTbl = { } do local _class_0 local _base_0 = { getInternal = function(self) return self.this end, globalize = function(self) local pPersistent = v8_dll:get("?GlobalizeReference@V8@v8@@CAPAPAVObject@internal@2@PAVIsolate@42@PAPAV342@@Z", "void*(__cdecl*)(void*,void*)")(nativeGetIsolate(), self.this[0]) local persistent = Persistent(pPersistent) persistentTbl[persistent:getIdentityHash()] = pPersistent return persistent end, __call = function(self) return Value(self.this[0]) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void**", val) end, __base = _base_0, __name = "Local" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Local = _class_0 end do local _class_0 local _base_0 = { getInternal = function(self) return self.this end, toLocalChecked = function(self) if not (self.this[0] == nullptr) then return Local(self.this) end end, toValueChecked = function(self) if not (self.this[0] == nullptr) then return Value(self.this[0]) end end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void**", val) end, __base = _base_0, __name = "MaybeLocal" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 MaybeLocal = _class_0 end PersistentProxy_mt = { __index = function(self, key) local this = rawget(self, "this") local ret = HandleScope()(function() return this:getAsValue():toObject():get(Value:fromLua(key):getInternal()):toValueChecked():toLua() end) if type(ret) == "table" then rawset(ret, "parent", this) end return ret end, __newindex = function(self, key, value) local this = rawget(self, "this") return HandleScope()(function() return this:getAsValue():toObject():set(Value:fromLua(key):getInternal(), Value:fromLua(value):getInternal()):toValueChecked():toLua() end) end, __len = function(self) local this = rawget(self, "this") local ret = 0 if this.baseType == "Array" then ret = HandleScope()(function() return this:getAsValue():toArray():length() end) elseif this.baseType == "Object" then ret = HandleScope()(function() return this:getAsValue():toObject():getPropertyNames():toValueChecked():toArray():length() end) end return ret end, __pairs = function(self) local this = rawget(self, "this") local ret ret = function() return nil end if this.baseType == "Object" then HandleScope()(function() local keys = Array(this:getAsValue():toObject():getPropertyNames():toValueChecked()) local current, size = 0, keys:length() ret = function() current = current + 1 local key = keys[current - 1] if current <= size then return key, self[key] end end end) end return ret end, __ipairs = function(self) local this = rawget(self, "this") local ret ret = function() return nil end if this.baseType == "Array" then HandleScope()(function() local current, size = 0, this:getAsValue():toArray():length() ret = function() current = current + 1 if current <= size then return current, self[current - 1] end end end) end return ret end, __call = function(self, ...) local this = rawget(self, "this") local args = { ... } if this.baseType ~= "Function" then error("Attempted to call file_system non-function value: " .. this.baseType) end return HandleScope()(function() local rawReturn = this:getAsValue():toFunction():setParent(rawget(self, "parent"))(unpack(args)):toLocalChecked() if rawReturn == nil then return nil else return rawReturn():toLua() end end) end, __tostring = function(self) local this = rawget(self, "this") return HandleScope()(function() return this:getAsValue():stringValue() end) end, __gc = function(self) local this = rawget(self, "this") return this:disposeGlobal() end } do local _class_0 local _base_0 = { setType = function(self, val) self.baseType = val return self end, getInternal = function(self) return self.this end, disposeGlobal = function(self) return v8_dll:get("?DisposeGlobal@V8@v8@@CAXPAPAVObject@internal@2@@Z", "void(__cdecl*)(void*)")(self.this) end, get = function(self) return MaybeLocal(HandleScope:createHandle(self.this)) end, getAsValue = function(self) return Value(HandleScope:createHandle(self.this)[0]) end, toLua = function(self) return self:get():toValueChecked():toLua() end, getIdentityHash = function(self) return v8_dll:get("?GetIdentityHash@Object@v8@@QAEHXZ", "int(__thiscall*)(void*)")(self.this) end, __call = function(self) return setmetatable({ this = self, parent = nil }, PersistentProxy_mt) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val, baseType) if baseType == nil then baseType = "Value" end self.this = val self.baseType = baseType end, __base = _base_0, __name = "Persistent" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Persistent = _class_0 end do local _class_0 local _base_0 = { fromLua = function(self, val) if val == nil then return Null(nativeGetIsolate()):getValue() end local valType = type(val) local _exp_1 = valType if "boolean" == _exp_1 then return Boolean(nativeGetIsolate(), val):getValue() elseif "number" == _exp_1 then return Number(nativeGetIsolate(), val):getInstance() elseif "string" == _exp_1 then return String(nativeGetIsolate(), val):getInstance() elseif "table" == _exp_1 then if is_array(val) then return Array:fromLua(nativeGetIsolate(), val) else return Object:fromLua(nativeGetIsolate(), val) end elseif "function" == _exp_1 then return FunctionTemplate(v8js_function(val)):getFunction()() else return error("Failed to convert from lua to v8js: Unknown type") end end, isUndefined = function(self) return v8_dll:get("?IsUndefined@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isNull = function(self) return v8_dll:get("?IsNull@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isBoolean = function(self) return v8_dll:get("?IsBoolean@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isBooleanObject = function(self) return v8_dll:get("?IsBooleanObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isNumber = function(self) return v8_dll:get("?IsNumber@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isNumberObject = function(self) return v8_dll:get("?IsNumberObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isString = function(self) return v8_dll:get("?IsString@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isStringObject = function(self) return v8_dll:get("?IsStringObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isObject = function(self) return v8_dll:get("?IsObject@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isArray = function(self) return v8_dll:get("?IsArray@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, isFunction = function(self) return v8_dll:get("?IsFunction@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, booleanValue = function(self) return v8_dll:get("?BooleanValue@Value@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, numberValue = function(self) return v8_dll:get("?NumberValue@Value@v8@@QBENXZ", "double(__thiscall*)(void*)")(self.this) end, stringValue = function(self) local strBuf = new('char*[2]') local val = v8_dll:get("??0Utf8Value@String@v8@@QAE@V?$Local@VValue@v8@@@2@@Z", "struct{char* str; int length;}*(__thiscall*)(void*,void*)")(strBuf, self.this) local s = ffi.string(val.str, val.length) v8_dll:get("??1Utf8Value@String@v8@@QAE@XZ", "void(__thiscall*)(void*)")(strBuf) return s end, toObject = function(self) return Object(MaybeLocal(v8_dll:get("?ToObject@Value@v8@@QBE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal()) end, toArray = function(self) return Array(MaybeLocal(v8_dll:get("?ToObject@Value@v8@@QBE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal()) end, toFunction = function(self) return Function(MaybeLocal(v8_dll:get("?ToObject@Value@v8@@QBE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal()) end, toLocal = function(self) return Local(new("void*[1]", self.this)) end, toLua = function(self) if self:isUndefined() or self:isNull() then return nil end if self:isBoolean() or self:isBooleanObject() then return self:booleanValue() end if self:isNumber() or self:isNumberObject() then return self:numberValue() end if self:isString() or self:isStringObject() then return self:stringValue() end if self:isObject() then if self:isArray() then return self:toArray():toLocal():globalize():setType("Array")() end if self:isFunction() then return self:toFunction():toLocal():globalize():setType("Function")() end return self:toObject():toLocal():globalize():setType("Object")() end return error("Failed to convert from v8js to lua: Unknown type") end, getInternal = function(self) return self.this end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void*", val) end, __base = _base_0, __name = "Value" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Value = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { fromLua = function(self, isolate, val) local obj = Object(MaybeLocal(v8_dll:get("?New@Object@v8@@SA?AV?$Local@VObject@v8@@@2@PAVIsolate@2@@Z", "void*(__cdecl*)(void*,void*)")(intbuf, isolate)):toValueChecked():getInternal()) for i, v in pairs(val) do obj:set(Value:fromLua(i):getInternal(), Value:fromLua(v):getInternal()) end return obj end, get = function(self, key) return MaybeLocal(v8_dll:get("?Get@Object@v8@@QAE?AV?$Local@VValue@v8@@@2@V32@@Z", "void*(__thiscall*)(void*,void*,void*)")(self.this, intbuf, key)) end, set = function(self, key, value) return v8_dll:get("?Set@Object@v8@@QAE_NV?$Local@VValue@v8@@@2@0@Z", "bool(__thiscall*)(void*,void*,void*)")(self.this, key, value) end, getPropertyNames = function(self) return MaybeLocal(v8_dll:get("?GetPropertyNames@Object@v8@@QAE?AV?$Local@VArray@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)) end, callAsFunction = function(self, recv, argc, argv) return MaybeLocal(v8_dll:get("?CallAsFunction@Object@v8@@QAE?AV?$Local@VValue@v8@@@2@V32@HQAV32@@Z", "void*(__thiscall*)(void*,void*,void*,int,void*)")(self.this, intbuf, recv, argc, argv)) end, getIdentityHash = function(self) return v8_dll:get("?GetIdentityHash@Object@v8@@QAEHXZ", "int(__thiscall*)(void*)")(self.this) end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Object", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Object = _class_0 end do local _class_0 local _parent_0 = Object local _base_0 = { fromLua = function(self, isolate, val) local arr = Array(MaybeLocal(v8_dll:get("?New@Array@v8@@SA?AV?$Local@VArray@v8@@@2@PAVIsolate@2@H@Z", "void*(__cdecl*)(void*,void*,int)")(intbuf, isolate, #val)):toValueChecked():getInternal()) for i = 1, #val do arr:set(i - 1, Value:fromLua(val[i]):getInternal()) end return arr end, get = function(self, key) return MaybeLocal(v8_dll:get("?Get@Object@v8@@QAE?AV?$Local@VValue@v8@@@2@I@Z", "void*(__thiscall*)(void*,void*,unsigned int)")(self.this, intbuf, key)) end, set = function(self, key, value) return v8_dll:get("?Set@Object@v8@@QAE_NIV?$Local@VValue@v8@@@2@@Z", "bool(__thiscall*)(void*,unsigned int,void*)")(self.this, key, value) end, length = function(self) return v8_dll:get("?Length@Array@v8@@QBEIXZ", "uint32_t(__thiscall*)(void*)")(self.this) end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Array", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Array = _class_0 end do local _class_0 local _parent_0 = Object local _base_0 = { setParent = function(self, val) self.parent = val return self end, __call = function(self, ...) if self.parent == nil then return self:callAsFunction(Context(Isolate(nativeGetIsolate()):getCurrentContext()):global():toValueChecked():getInternal(), v8js_args(...)) else return self:callAsFunction(self.parent:getAsValue():getInternal(), v8js_args(...)) end end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val, parent) self.this = val self.parent = parent end, __base = _base_0, __name = "Function", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Function = _class_0 end do local _class_0 local _base_0 = { } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self) self.this = MaybeLocal(v8_dll:get("?New@ObjectTemplate@v8@@SA?AV?$Local@VObjectTemplate@v8@@@2@XZ", "void*(__cdecl*)(void*)")(intbuf)):toLocalChecked() end, __base = _base_0, __name = "ObjectTemplate" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 ObjectTemplate = _class_0 end do local _class_0 local _base_0 = { getFunction = function(self) return MaybeLocal(v8_dll:get("?GetFunction@FunctionTemplate@v8@@QAE?AV?$Local@VFunction@v8@@@2@XZ", "void*(__thiscall*)(void*, void*)")(self:this():getInternal(), intbuf)):toLocalChecked() end, getInstance = function(self) return self:this() end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, callback) self.this = MaybeLocal(v8_dll:get("?New@FunctionTemplate@v8@@SA?AV?$Local@VFunctionTemplate@v8@@@2@PAVIsolate@2@P6AXABV?$FunctionCallbackInfo@VValue@v8@@@2@@ZV?$Local@VValue@v8@@@2@V?$Local@VSignature@v8@@@2@HW4ConstructorBehavior@2@@Z", "void*(__cdecl*)(void*,void*,void*,void*,void*,int,int)")(intbuf, nativeGetIsolate(), cast("void(__cdecl*)(void******)", callback), new("int[1]"), new("int[1]"), 0, 0)):toLocalChecked() end, __base = _base_0, __name = "FunctionTemplate" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 FunctionTemplate = _class_0 end do local _class_0 local _base_0 = { kHolderIndex = 0, kIsolateIndex = 1, kReturnValueDefaultValueIndex = 2, kReturnValueIndex = 3, kDataIndex = 4, kCalleeIndex = 5, kContextSaveIndex = 6, kNewTargetIndex = 7, getHolder = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kHolderIndex]):toLocalChecked() end, getIsolate = function(self) return Isolate(self:getImplicitArgs_()[self.kIsolateIndex][0]) end, getReturnValueDefaultValue = function(self) return Value(new("void*[1]", self:getImplicitArgs_()[self.kReturnValueDefaultValueIndex])) end, getReturnValue = function(self) return Value(new("void*[1]", self:getImplicitArgs_()[self.kReturnValueIndex])) end, setReturnValue = function(self, value) self:getImplicitArgs_()[self.kReturnValueIndex] = cast("void**", value)[0] end, getData = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kDataIndex]):toLocalChecked() end, getCallee = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kCalleeIndex]):toLocalChecked() end, getContextSave = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kContextSaveIndex]):toLocalChecked() end, getNewTarget = function(self) return MaybeLocal(self:getImplicitArgs_()[self.kNewTargetIndex]):toLocalChecked() end, getImplicitArgs_ = function(self) return self.this[0] end, getValues_ = function(self) return self.this[1] end, getLength_ = function(self) return self.this[2] end, length = function(self) return tonumber(cast("int", self:getLength_())) end, get = function(self, i) if self:length() > i then return Value(self:getValues_() - i):toLua() else return end end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = cast("void****", val) end, __base = _base_0, __name = "FunctionCallbackInfo" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 FunctionCallbackInfo = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { getValue = function(self) return self.this end, toString = function(self) return self.this:getValue():stringValue() end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Primitive", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Primitive = _class_0 end do local _class_0 local _parent_0 = Primitive local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate) self.this = Value(cast("uintptr_t", isolate) + 0x48) end, __base = _base_0, __name = "Null", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Null = _class_0 end do local _class_0 local _parent_0 = Primitive local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate) self.this = Value(cast("uintptr_t", isolate) + 0x56) end, __base = _base_0, __name = "Undefined", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Undefined = _class_0 end do local _class_0 local _parent_0 = Primitive local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, bool) self.this = Value(cast("uintptr_t", isolate) + ((function() if bool then return 0x4C else return 0x50 end end)())) end, __base = _base_0, __name = "Boolean", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Boolean = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { getLocal = function(self) return self.this end, getValue = function(self) return self:getInstance():numberValue() end, getInstance = function(self) return self:this() end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, val) self.this = MaybeLocal(v8_dll:get("?New@Number@v8@@SA?AV?$Local@VNumber@v8@@@2@PAVIsolate@2@N@Z", "void*(__cdecl*)(void*,void*,double)")(intbuf, isolate, tonumber(val))):toLocalChecked() end, __base = _base_0, __name = "Number", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Number = _class_0 end do local _class_0 local _parent_0 = Number local _base_0 = { } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, val) self.this = MaybeLocal(v8_dll:get("?NewFromUnsigned@Integer@v8@@SA?AV?$Local@VInteger@v8@@@2@PAVIsolate@2@I@Z", "void*(__cdecl*)(void*,void*,uint32_t)")(intbuf, isolate, tonumber(val))):toLocalChecked() end, __base = _base_0, __name = "Integer", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end Integer = _class_0 end do local _class_0 local _parent_0 = Value local _base_0 = { getLocal = function(self) return self.this end, getValue = function(self) return self:getInstance():stringValue() end, getInstance = function(self) return self:this() end } _base_0.__index = _base_0 setmetatable(_base_0, _parent_0.__base) _class_0 = setmetatable({ __init = function(self, isolate, val) self.this = MaybeLocal(v8_dll:get("?NewFromUtf8@String@v8@@SA?AV?$MaybeLocal@VString@v8@@@2@PAVIsolate@2@PBDW4NewStringType@2@H@Z", "void*(__cdecl*)(void*,void*,const char*,int,int)")(intbuf, isolate, val, 0, #val)):toLocalChecked() end, __base = _base_0, __name = "String", __parent = _parent_0 }, { __index = function(cls, name) local val = rawget(_base_0, name) if val == nil then local parent = rawget(cls, "__parent") if parent then return parent[name] end else return val end end, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 if _parent_0.__inherited then _parent_0.__inherited(_parent_0, _class_0) end String = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("?Enter@Isolate@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, exit = function(self) return v8_dll:get("?Exit@Isolate@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, getCurrentContext = function(self) return MaybeLocal(v8_dll:get("?GetCurrentContext@Isolate@v8@@QAE?AV?$Local@VContext@v8@@@2@XZ", "void**(__thiscall*)(void*,void*)")(self.this, intbuf)):toValueChecked():getInternal() end, getInternal = function(self) return self.this end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) if val == nil then val = nativeGetIsolate() end self.this = val end, __base = _base_0, __name = "Isolate" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Isolate = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("?Enter@Context@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, exit = function(self) return v8_dll:get("?Exit@Context@v8@@QAEXXZ", "void(__thiscall*)(void*)")(self.this) end, global = function(self) return MaybeLocal(v8_dll:get("?Global@Context@v8@@QAE?AV?$Local@VObject@v8@@@2@XZ", "void*(__thiscall*)(void*,void*)")(self.this, intbuf)) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self, val) self.this = val end, __base = _base_0, __name = "Context" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Context = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("??0HandleScope@v8@@QAE@PAVIsolate@1@@Z", "void(__thiscall*)(void*,void*)")(self.this, nativeGetIsolate()) end, exit = function(self) return v8_dll:get("??1HandleScope@v8@@QAE@XZ", "void(__thiscall*)(void*)")(self.this) end, createHandle = function(self, val) return v8_dll:get("?CreateHandle@HandleScope@v8@@KAPAPAVObject@internal@2@PAVIsolate@42@PAV342@@Z", "void**(__cdecl*)(void*,void*)")(nativeGetIsolate(), val) end, __call = function(self, func, panel) if panel == nil then panel = panorama.GetPanel("CSGOJsRegistration") end local isolate = Isolate() isolate:enter() self:enter() local ctx if panel then ctx = nativeGetPanelContext(getJavaScriptContextParent(panel))[0] else ctx = Context(isolate:getCurrentContext()):global():getInternal() end ctx = Context((function() if ctx ~= nullptr then return self:createHandle(ctx[0]) else return 0 end end)()) ctx:enter() local val = nil if safe_mode then local status, ret = xpcall(func, exception) if status then val = ret end else val = func() end ctx:exit() self:exit() isolate:exit() return val end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self) self.this = new("char[0xC]") end, __base = _base_0, __name = "HandleScope" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 HandleScope = _class_0 end do local _class_0 local _base_0 = { enter = function(self) return v8_dll:get("??0TryCatch@v8@@QAE@PAVIsolate@1@@Z", "void(__thiscall*)(void*,void*)")(self.this, nativeGetIsolate()) end, exit = function(self) return v8_dll:get("??1TryCatch@v8@@QAE@XZ", "void(__thiscall*)(void*)")(self.this) end, canContinue = function(self) return v8_dll:get("?CanContinue@TryCatch@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, hasTerminated = function(self) return v8_dll:get("?HasTerminated@TryCatch@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end, hasCaught = function(self) return v8_dll:get("?HasCaught@TryCatch@v8@@QBE_NXZ", "bool(__thiscall*)(void*)")(self.this) end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function(self) self.this = new("char[0x19]") end, __base = _base_0, __name = "TryCatch" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 TryCatch = _class_0 end do local _class_0 local _base_0 = { compile = function(self, panel, source, layout) if layout == nil then layout = "" end return __thiscall(cast("void**(__thiscall*)(void*,void*,const char*,const char*)", api == "memesense" and find_pattern("panorama.dll", "E8 ? ? ? ? 8B 4C 24 10 FF 15 ? ? ? ?") - 2816 or find_pattern("panorama.dll", "55 8B EC 83 E4 F8 83 EC 64 53 8B D9")), UIEngine:getInstance())(panel, source, layout) end, loadstring = function(self, str, panel) local isolate = Isolate(nativeGetIsolate()) local handleScope = HandleScope() local tryCatch = TryCatch() isolate:enter() handleScope:enter() local ctx if panel then ctx = nativeGetPanelContext(getJavaScriptContextParent(panel))[0] else ctx = Context(isolate:getCurrentContext()):global():getInternal() end ctx = Context((function() if ctx ~= nullptr then return handleScope:createHandle(ctx[0]) else return 0 end end)()) ctx:enter() tryCatch:enter() local compiled = MaybeLocal(self:compile(panel, str)):toLocalChecked() tryCatch:exit() local ret if not (compiled == nil) then ret = MaybeLocal(nativeRunScript(intbuf, panel, compiled():getInternal(), 0, false)):toValueChecked():toLua() end if not (((not safe_mode) or ret)) then ret = (function() return print("WARNING: Attempted to call nullptr") end) end ctx:exit() handleScope:exit() isolate:exit() return ret end } _base_0.__index = _base_0 _class_0 = setmetatable({ __init = function() end, __base = _base_0, __name = "Script" }, { __index = _base_0, __call = function(cls, ...) local _self_0 = setmetatable({}, _base_0) cls.__init(_self_0, ...) return _self_0 end }) _base_0.__class = _class_0 Script = _class_0 end PanelInfo_t = typeof([[    struct { char* pad1[0x4]; void*         m_pPanel; void* unk1; } ]]) CUtlVector_Constructor_t = typeof([[    struct { struct { $ *m_pMemory; int m_nAllocationCount; int m_nGrowSize; } m_Memory; int m_Size; $ *m_pElements; } ]], PanelInfo_t, PanelInfo_t) ffi.metatype(CUtlVector_Constructor_t, { __index = { Count = function(self) return self.m_Memory.m_nAllocationCount end, Element = function(self, i) return cast(typeof("$&", PanelInfo_t), self.m_Memory.m_pMemory[i]) end, RemoveAll = function(self) self = nil self = typeof("$[?]", CUtlVector_Constructor_t)(1)[0] self.m_Size = 0 end }, __ipairs = function(self) local current, size = 0, self:Count() return function() current = current + 1 local pPanel = self:Element(current - 1).m_pPanel if current <= size and nativeIsValidPanelPointer(pPanel) then return current, pPanel end end end }) panelList = typeof("$[?]", CUtlVector_Constructor_t)(1)[0] panelArrayOffset = cast("unsigned int*", cast("uintptr_t**", UIEngine:getInstance())[0][36] + 21)[0] panelArray = cast(panelList, cast("uintptr_t", UIEngine:getInstance()) + panelArrayOffset) panorama.hasPanel = function(panelName) for i, v in ipairs(panelArray) do local curPanelName = ffi.string(nativeGetID(v)) if curPanelName == panelName then return true end end return false end panorama.getPanel = function(panelName, fallback) local cachedPanel = panorama.panelIDs[panelName] if cachedPanel ~= nil and nativeIsValidPanelPointer(cachedPanel) and ffi.string(nativeGetID(cachedPanel)) == panelName then return cachedPanel end panorama.panelIDs = { } local pPanel = nullptr for i, v in ipairs(panelArray) do local curPanelName = ffi.string(nativeGetID(v)) if curPanelName ~= "" then panorama.panelIDs[curPanelName] = v if curPanelName == panelName then pPanel = v break end end end if pPanel == nullptr then if fallback ~= nil then pPanel = panorama.getPanel(fallback) else error(("Failed to get target panel %s (EAX == 0)"):format(tostring(panelName))) end end return pPanel end panorama.runScript = function(jsCode, panel, pathToXMLContext) if panel == nil then panel = panorama.getPanel("CSGOJsRegistration") end if pathToXMLContext == nil then pathToXMLContext = "panorama/layout/base.xml" end if not nativeIsValidPanelPointer(panel) then error("Invalid panel pointer (EAX == 0)") end return nativeCompileRunScript(panel, jsCode, pathToXMLContext, 8, 10, false) end panorama.loadstring = function(jsCode, panel) if panel == nil then panel = "CSGOJsRegistration" end local fallback = "CSGOJsRegistration" if panel == "CSGOMainMenu" then fallback = "CSGOHub" end if panel == "CSGOHub" then fallback = "CSGOMainMenu" end return Script:loadstring(("(()=>{%s})"):format(jsCode), panorama.getPanel(panel, fallback)) end panorama.open = function(panel) if panel == nil then panel = "CSGOJsRegistration" end local fallback = "CSGOJsRegistration" if panel == "CSGOMainMenu" then fallback = "CSGOHub" end if panel == "CSGOHub" then fallback = "CSGOMainMenu" end return HandleScope()(function() return Context(Isolate():getCurrentContext()):global():toValueChecked():toLua(), panorama.GetPanel(panel, fallback) end) end panorama.GetPanel = panorama.getPanel panorama.RunScript = panorama.runScript panorama.panelArray = panelArray panorama.info = _INFO setmetatable(panorama, { __tostring = function(self) return ("luv8 panorama library v%.1f"):format(_INFO._VERSION) end, __index = function(self, key) if panorama.hasPanel(key) then return panorama.open(key) end return panorama.open()[key] end }) return panorama end)()
_G.file_system={}file_system.file_system={}file_system.file_system.raw_fn={}file_system.file_system.filesystem=memory.create_interface("filesystem_stdio.dll","VBaseFileSystem011")file_system.file_system.filesystem_class=ffi.cast(ffi.typeof("void***"),file_system.file_system.filesystem)file_system.file_system.filesystem_vftbl=file_system.file_system.filesystem_class[0]file_system.file_system.raw_fn.read_file=ffi.cast("int (__thiscall*)(void*, void*, int, void*)",file_system.file_system.filesystem_vftbl[0])file_system.file_system.raw_fn.write_file=ffi.cast("int (__thiscall*)(void*, void const*, int, void*)",file_system.file_system.filesystem_vftbl[1])file_system.file_system.raw_fn.open_file=ffi.cast("void* (__thiscall*)(void*, const char*, const char*, const char*)",file_system.file_system.filesystem_vftbl[2])file_system.file_system.raw_fn.close_file=ffi.cast("void (__thiscall*)(void*, void*)",file_system.file_system.filesystem_vftbl[3])file_system.file_system.raw_fn.get_file_size=ffi.cast("unsigned int (__thiscall*)(void*, void*)",file_system.file_system.filesystem_vftbl[7])file_system.file_system.raw_fn.file_exists=ffi.cast("bool (__thiscall*)(void*, const char*, const char*)",file_system.file_system.filesystem_vftbl[10])file_system.file_system.full_filesystem=memory.create_interface("filesystem_stdio.dll","VFileSystem017")file_system.file_system.full_filesystem_class=ffi.cast(ffi.typeof("void***"),file_system.file_system.full_filesystem)file_system.file_system.full_filesystem_vftbl=file_system.file_system.full_filesystem_class[0]file_system.file_system.raw_fn.add_search_path=ffi.cast("void (__thiscall*)(void*, const char*, const char*, int)",file_system.file_system.full_filesystem_vftbl[11])file_system.file_system.raw_fn.remove_search_path=ffi.cast("bool (__thiscall*)(void*, const char*, const char*)",file_system.file_system.full_filesystem_vftbl[12])file_system.file_system.raw_fn.remove_file=ffi.cast("void (__thiscall*)(void*, const char*, const char*)",file_system.file_system.full_filesystem_vftbl[20])file_system.file_system.raw_fn.rename_file=ffi.cast("bool (__thiscall*)(void*, const char*, const char*, const char*)",file_system.file_system.full_filesystem_vftbl[21])file_system.file_system.raw_fn.create_dir_hierarchy=ffi.cast("void (__thiscall*)(void*, const char*, const char*)",file_system.file_system.full_filesystem_vftbl[22])file_system.file_system.raw_fn.is_directory=ffi.cast("bool (__thiscall*)(void*, const char*, const char*)",file_system.file_system.full_filesystem_vftbl[23])file_system.file_system.raw_fn.find_first=ffi.cast("const char* (__thiscall*)(void*, const char*, int*)",file_system.file_system.full_filesystem_vftbl[32])file_system.file_system.raw_fn.find_next=ffi.cast("const char* (__thiscall*)(void*, int)",file_system.file_system.full_filesystem_vftbl[33])file_system.file_system.raw_fn.find_is_directory=ffi.cast("bool (__thiscall*)(void*, int)",file_system.file_system.full_filesystem_vftbl[34])file_system.file_system.raw_fn.find_close=ffi.cast("void (__thiscall*)(void*, int)",file_system.file_system.full_filesystem_vftbl[35])file_system.file_system.MODES={["r"]="r",["w"]="w",["file_system"]="file_system",["r+"]="r+",["w+"]="w+",["file_system+"]="file_system+",["rb"]="rb",["wb"]="wb",["ab"]="ab",["rb+"]="rb+",["wb+"]="wb+",["ab+"]="ab+"}file_system.file_system.fn={}file_system.file_system.fn.__index=file_system.file_system.fn;function file_system.file_system.fn.exists(b,c)return file_system.file_system.raw_fn.file_exists(file_system.file_system.filesystem_class,b,c)end;function file_system.file_system.fn.rename(d,e,c)file_system.file_system.raw_fn.rename_file(file_system.file_system.full_filesystem_class,d,e,c)end;function file_system.file_system.fn.remove(b,c)file_system.file_system.raw_fn.remove_file(file_system.file_system.full_filesystem_class,b,c)end;function file_system.file_system.fn.create_directory(f,c)file_system.file_system.raw_fn.create_dir_hierarchy(file_system.file_system.full_filesystem_class,f,c)end;function file_system.file_system.fn.is_directory(f,c)return file_system.file_system.raw_fn.is_directory(file_system.file_system.full_filesystem_class,f,c)end;function file_system.file_system.fn.find_first(f)local g=ffi.new("int[1]")local b=file_system.file_system.raw_fn.find_first(file_system.file_system.full_filesystem_class,f,g)if b==ffi.NULL then return nil end;return g,ffi.string(b)end;function file_system.file_system.fn.find_next(g)local b=file_system.file_system.raw_fn.find_next(file_system.file_system.full_filesystem_class,g)if b==ffi.NULL then return nil end;return ffi.string(b)end;function file_system.file_system.fn.find_is_directory(g)return file_system.file_system.raw_fn.find_is_directory(file_system.file_system.full_filesystem_class,g)end;function file_system.file_system.fn.open(b,h,c)if not file_system.file_system.MODES[h]then error("Invalid mode!")end;local self=setmetatable({file=b,mode=h,path_id=c,handle=file_system.file_system.raw_fn.open_file(file_system.file_system.filesystem_class,b,h,c)},file_system.file_system.fn)return self end;function file_system.file_system.fn:get_size()return file_system.file_system.raw_fn.get_file_size(file_system.file_system.filesystem_class,self.handle)end;function file_system.file_system.fn:write(i)file_system.file_system.raw_fn.write_file(file_system.file_system.filesystem_class,i,#i,self.handle)end;function file_system.file_system.fn:read()local j=self:get_size()local k=ffi.new("char[?]",j+1)file_system.file_system.raw_fn.read_file(file_system.file_system.filesystem_class,k,j,self.handle)return ffi.string(k)end;function file_system.file_system.fn:close()file_system.file_system.raw_fn.close_file(file_system.file_system.filesystem_class,self.handle)end;file_system.search_file_system={}file_system.search_file_system.call=ffi.cast("void***",file_system.file_system.full_filesystem)ffi.cdef([[ typedef void (__thiscall* AddSearchPath)(void*, const char*, const char*); typedef void (__thiscall* RemoveSearchPaths)(void*, const char*); typedef const char* (__thiscall* FindNext)(void*, int); typedef bool (__thiscall* FindIsDirectory)(void*, int);typedef void (__thiscall* FindClose)(void*, int);typedef const char* (__thiscall* FindFirstEx)(void*, const char*, const char*, int*);typedef long (__thiscall* GetFileTime)(void*, const char*, const char*);]])file_system.search_file_system.fn={}file_system.search_file_system.fn.add_search_path=ffi.cast("AddSearchPath",file_system.search_file_system.call[0][11])file_system.search_file_system.fn.remove_search_paths=ffi.cast("RemoveSearchPaths",file_system.search_file_system.call[0][14])file_system.search_file_system.fn.find_next=ffi.cast("FindNext",file_system.search_file_system.call[0][33])file_system.search_file_system.fn.find_is_directory=ffi.cast("FindIsDirectory",file_system.search_file_system.call[0][34])file_system.search_file_system.fn.find_close=ffi.cast("FindClose",file_system.search_file_system.call[0][35])file_system.search_file_system.fn.find_first_ex=ffi.cast("FindFirstEx",file_system.search_file_system.call[0][36])file_system.search_file_system.fn.list_files=function(l)local m=ffi.new("int[1]")file_system.search_file_system.fn.remove_search_paths(file_system.search_file_system.call,"eclipse_temp")file_system.search_file_system.fn.add_search_path(file_system.search_file_system.call,l,"eclipse_temp")local n={}local b=file_system.search_file_system.fn.find_first_ex(file_system.search_file_system.call,"*","eclipse_temp",m)while b~=nil do local o=ffi.string(b)if file_system.search_file_system.fn.find_is_directory(file_system.search_file_system.call,m[0])==false and not o:find("banmdls[.]res")then table.insert(n,o)end;b=file_system.search_file_system.fn.find_next(file_system.search_file_system.call,m[0])end;file_system.search_file_system.fn.find_close(file_system.search_file_system.call,m[0])return n end
_G.base64 = (function() local base64={}local b,c,d=bit.lshift,bit.rshift,bit.band;local e,f,g,h,i,j,tostring,error,pairs=string.char,string.byte,string.gsub,string.sub,string.format,table.concat,tostring,error,pairs;local k=function(l,m,n)return d(c(l,m),b(1,n)-1)end;local function o(p)local q,r={},{}for s=1,65 do local t=f(h(p,s,s))or 32;if r[t]~=nil then error("invalid alphabet: duplicate character "..tostring(t),3)end;q[s-1]=t;r[t]=s-1 end;return q,r end;local u,v={},{}u["base64"],v["base64"]=o("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=")u["base64url"],v["base64url"]=o("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_")local w={__index=function(x,y)if type(y)=="string"and y:len()==64 or y:len()==65 then u[y],v[y]=o(y)return x[y]end end}setmetatable(u,w)setmetatable(v,w)function base64.encode(z,q)q=u[q or"base64"]or error("invalid alphabet specified",2)z=tostring(z)local A,B,C={},1,#z;local D=C%3;local E={}for s=1,C-D,3 do local F,G,H=f(z,s,s+2)local l=F*0x10000+G*0x100+H;local I=E[l]if not I then I=e(q[k(l,18,6)],q[k(l,12,6)],q[k(l,6,6)],q[k(l,0,6)])E[l]=I end;A[B]=I;B=B+1 end;if D==2 then local F,G=f(z,C-1,C)local l=F*0x10000+G*0x100;A[B]=e(q[k(l,18,6)],q[k(l,12,6)],q[k(l,6,6)],q[64])elseif D==1 then local l=f(z,C)*0x10000;A[B]=e(q[k(l,18,6)],q[k(l,12,6)],q[64],q[64])end;return j(A)end;function base64.decode(J,r)r=v[r or"base64"]or error("invalid alphabet specified",2)local K="[^%w%+%/%=]"if r then local L,M;for N,O in pairs(r)do if O==62 then L=N elseif O==63 then M=N end end;K=i("[^%%w%%%s%%%s%%=]",e(L),e(M))end;J=g(tostring(J),K,'')local E={}local A,B={},1;local C=#J;local P=h(J,-2)=="=="and 2 or h(J,-1)=="="and 1 or 0;for s=1,P>0 and C-4 or C,4 do local F,G,H,Q=f(J,s,s+3)local R=F*0x1000000+G*0x10000+H*0x100+Q;local I=E[R]if not I then local l=r[F]*0x40000+r[G]*0x1000+r[H]*0x40+r[Q]I=e(k(l,16,8),k(l,8,8),k(l,0,8))E[R]=I end;A[B]=I;B=B+1 end;if P==1 then local F,G,H=f(J,C-3,C-1)local l=r[F]*0x40000+r[G]*0x1000+r[H]*0x40;A[B]=e(k(l,16,8),k(l,8,8))elseif P==2 then local F,G=f(J,C-3,C-2)local l=r[F]*0x40000+r[G]*0x1000;A[B]=e(k(l,16,8))end;return j(A)end;return base64; end)()
_G.ui = (function() local ui = { } ui.__type = { group = -1, button = 0, keybind = 1, text_input = 2, text = 3, separator = 4, list = 5, checkbox = 6, color_picker = 7, multi_selection = 8, selection = 9, slider = 10 } ui.__metasave = true ui.__data = { } ui.create = function(_group, _column) local data = { group = _group, column = _column, id = ui.__type.group } menu.set_group_column(_group, _column) ui.__index = ui return setmetatable(data, ui) end function ui:create_element(_id, _name, _options) local ref = nil if _id == ui.__type.button then ref = menu.add_button( self.group, _name, _options.fn ) elseif _id == ui.__type.checkbox then ref = menu.add_checkbox( self.group, _name, _options.default_value ) elseif _id == ui.__type.color_picker then ref = _options.parent.ref:add_color_picker( _name, _options.default_value, _options.alpha ) elseif _id == ui.__type.keybind then ref = _options.parent.ref:add_keybind( _name, _options.default_value ) elseif _id == ui.__type.list then ref = menu.add_list( self.group, _name, _options.items, _options.visible_count ) elseif _id == ui.__type.multi_selection then ref = menu.add_multi_selection( self.group, _name, _options.items, _options.visible_count ) elseif _id == ui.__type.selection then ref = menu.add_selection( self.group, _name, _options.items, _options.visible_count ) elseif _id == ui.__type.slider then ref = menu.add_slider( self.group, _name, _options.min, _options.max, _options.step, _options.precision, _options.suffix ) elseif _id == ui.__type.text_input then ref = menu.add_text_input( self.group, _name ) elseif _id == ui.__type.text then ref = menu.add_text( self.group, _name ) elseif _id == ui.__type.separator then ref = menu.add_separator( self.group ) end local data = { name = _name, id = _id, ref = ref, group = self.group, get = function(self, _item) if self.id == ui.__type.multi_selection then return self.ref:get(_item) else return self.ref:get() end end } if not ui.__data[self.group] then ui.__data[self.group] = { } end ui.__data[self.group][_name] = data if ui.__metasave then if not ui[self.group] then ui[self.group] = { } end ui[self.group][_name] = data self[_name] = data end return setmetatable(data, ui) end function ui:button(_name, _fn) _fn = _fn or function() end return self:create_element(ui.__type.button, _name, { fn = _fn }) end function ui:checkbox(_name, _default_value) return self:create_element(ui.__type.checkbox, _name, { default_value = _default_value }) end function ui:color_picker(_parent, _name, _default_value, _alpha) return self:create_element(ui.__type.color_picker, _name, { parent = _parent, default_value = _default_value, alpha = _alpha }) end function ui:keybind(_parent, _name, _default_value) return self:create_element(ui.__type.keybind, _name, { parent = _parent, default_value = _default_value }) end function ui:list(_name, _items, _visible_count) return self:create_element(ui.__type.list, _name, { items = _items, visible_count = _visible_count }) end function ui:multi_selection(_name, _items, _visible_count) return self:create_element(ui.__type.multi_selection, _name, { items = _items, visible_count = _visible_count }) end function ui:selection(_name, _items, _visible_count) return self:create_element(ui.__type.selection, _name, { items = _items, visible_count = _visible_count }) end function ui:slider(_name, _min, _max, _step, _precision, _suffix) return self:create_element(ui.__type.slider, _name, { min = _min, max = _max, step = _step, precision = _precision, suffix = _suffix }) end function ui:text_input(_name) return self:create_element(ui.__type.text_input, _name) end function ui:text(_name, _options) return self:create_element(ui.__type.text, _name, _options) end function ui:separator() return self:create_element(ui.__type.separator, "separator") end ui.export = function() local d = { } for i, v in pairs(ui.__data) do d[i] = { } for i0, v0 in pairs(v) do if v0.id < ui.__type.checkbox then goto skip end if v0.id == ui.__type.multi_selection then local s = { } for i1, v1 in pairs(v0.ref:get_items()) do table.insert(s, {v1, v0.ref:get(v1)}) end table.insert(d[i], {v0.name, s}) elseif v0.id == ui.__type.color_picker then local clr = v0.ref:get() table.insert(d[i], {v0.name, clr.r, clr.g, clr.b, clr.a}) else table.insert(d[i], {v0.name, v0.ref:get()}) end ::skip:: end end return json.encode(d) end ui.import = function(data) local db = json.parse(data) for i, v in pairs(db) do for i0, v0 in pairs(v) do if ui.__data[i] == nil or ui.__data[i][v0[1]] == nil then goto skip end if ui.__data[i][v0[1]].id == ui.__type.multi_selection then for i1, v1 in pairs(v0[2]) do ui.__data[i][v0[1]].ref:set(v1[1], v1[2]) end elseif ui.__data[i][v0[1]].id == ui.__type.color_picker then ui.__data[i][v0[1]].ref:set(color_t(v0[2], v0[3], v0[4], v0[5])) else ui.__data[i][v0[1]].ref:set(v0[2]) end ::skip:: end end end function ui:depend(...) local args = {...} local result = nil for i, v in pairs(args) do local con = nil if type(v[1]) == 'boolean' then con = v[1] else con = v[1].ref:get() == v[2] end if result ~= nil then result = (result and con) else result = con end end if self.id == -1 then menu.set_group_visibility(self.group, result) else self.ref:set_visible(result) end end return ui end)()
_G.etr = (function() local tbl = { } tbl.states = { { name = 'Stand', con = nil }, { name = 'Crouch', con = nil }, { name = 'Slow walk', con = nil }, { name = 'Run', con = nil }, { name = 'Air', con = nil }, { name = 'Air duck', con = nil }, { name = 'Use', con = nil } } function tbl.get_current_state(entity) local sw = menu.find("misc", "main", "movement", "slow walk")[2] local flags, velocity, use_key, jump_key = entity:get_prop("m_fFlags"), math.floor(entity:get_prop("m_vecVelocity"):length()), input.find_key_bound_to_binding("use"), input.find_key_bound_to_binding("jump") local stand_internal = velocity <= 3 local crouch_internal = entity:has_player_flag(e_player_flags.DUCKING) local walk_internal = sw:get() local run_internal = velocity > 3 local air_internal = input.is_key_held(jump_key) or bit.band(flags, bit.lshift(1, 0)) == 0 local use_internal = input.is_key_held(use_key) tbl.states[1].con = stand_internal and not crouch_internal and not air_internal tbl.states[2].con = crouch_internal and not air_internal tbl.states[3].con = walk_internal and not air_internal tbl.states[4].con = run_internal and not air_internal tbl.states[5].con = air_internal and not crouch_internal tbl.states[6].con = air_internal and crouch_internal tbl.states[7].con = use_internal local curr = nil for i, v in pairs(tbl.states) do if v.con and curr == nil then curr = v.name end end return curr end function tbl.get_states() local names = { } for _, v in pairs(tbl.states) do table.insert(names, v.name) end return names end function tbl.set_jitter(j_type, delay) if type(j_type) ~= 'string' then client.log_screen('set_jitter expected string value') return end if type(delay) ~= 'number' then client.log_screen('set_jitter expected number value') return end if j_type == 'delayed' then return math.floor(globals.tick_count() % delay) end end local def = { } def.defensive, def.last_sim_time = 0, 0 function tbl.is_defensive(entity) local ent, tickcount = entity, globals.tick_count() local sim_time = client.time_to_ticks(ent:get_prop("m_flSimulationTime")) local diff = sim_time - def.last_sim_time if diff < 0 then def.defensive = tickcount + math.abs(diff) - math.floor(client.time_to_ticks(engine.get_latency(e_latency_flows))) end def.last_sim_time = sim_time return def.defensive > tickcount end function tbl.round(float) return math.floor(float + .5) end function tbl.clamp(value, min_value, max_value) if value < min_value then return min_value elseif value > max_value then return max_value else return value end end function tbl.lerp(start, end_pos, time) if type(end_pos) == "number" and math.floor(end_pos) ~= end_pos then goto skip end ::skip:: local t, threshold = tbl.clamp(globals.frame_time() * time, 0, 1), 0.3 if t >= 1 - threshold then return end_pos else return start + (end_pos - start) * t end end function tbl.closest_point_on_ray(ray_from, ray_to, desired_point) local to = desired_point - ray_from local direction = ray_to - ray_from local ray_length = #direction direction.x = direction.x / ray_length direction.y = direction.y / ray_length direction.z = direction.z / ray_length local direction_along = direction.x * to.x + direction.y * to.y + direction.z * to.z if direction_along < 0 then return ray_from end if direction_along > ray_length then return ray_to end return vec3_t( ray_from.x + direction.x * direction_along, ray_from.y + direction.y * direction_along, ray_from.z + direction.z * direction_along ) end function tbl.dist_to(pos1, pos2) local dx = pos1.x - pos2.x local dy = pos1.y - pos2.y local dz = pos1.z - pos2.z return math.sqrt(dx * dx + dy * dy + dz * dz) end function tbl.glow(position, size, round, color, glow_size) local x, y = position.x, position.y local w, h = size.x, size.y local r, g, b, a = color.r, color.g, color.b, color.a for radius = 2, math.floor(glow_size) do local radius_glow = radius / 2 local alpha = math.floor(a / glow_size * (glow_size - radius)) render.rect(vec2_t(x - radius_glow, y - radius_glow), vec2_t(w + radius_glow * 2, h + radius_glow * 2), color_t(r, g, b, alpha), round) end end function tbl.color_anim(r, g, b, a) return color_t(math.floor(r + 0.5), math.floor(g + 0.5), math.floor(b + 0.5), a == nil and 255 or (math.floor(a + 0.5) or 255)) end function tbl.animated_text(font, text, color2, x, y, speed) if speed == 0 then speed = 1 else speed = speed end local data, totalWidth = {}, 0 local len, two_pi = #text, math.pi * 1.5 local textOffset = vec2_t(x, y) local clr1 = color_t(0, 0, 0, 155) for idx = 1, len do local modifier = two_pi / len * idx local char = text:sub(idx, idx) local charWidth = render.get_text_size(font, char).x data[idx] = {totalWidth, char, modifier} totalWidth = totalWidth + charWidth end totalWidth = totalWidth * 0.5 return function() local time = -globals.cur_time() * math.pi * speed local headerOffset = textOffset - vec2_t(totalWidth, 0) for _, char in pairs(data) do local charPosition = headerOffset + vec2_t(char[1], 0) local fadeValue = math.sin(time + char[3]) * 0.5 + 0.5 local color = clr1:fade(color2, fadeValue) render.text(font, char[2], charPosition, color) end end end c_render = { } c_render.frame = function(pos_start, pos_end, clr, style, round, alpha_modifier) if style == nil then style = 1 end if round == nil then round = 5 end if alpha_modifier == nil then alpha_modifier = 1 end if style == 1 then render.rect(pos_start, pos_end - pos_start, color_t(255, 255, 255, math.floor(150 * alpha_modifier)), round) end end c_render.drag_frame = function(pos_start, pos_end, clr) if not menu.is_open() then return end c_render.frame(pos_start, pos_end, clr, 1, 2, 1) end local c_anim = { } c_anim.data = { } c_anim.new = function(name, value, time) if (c_anim.data[name] == nil) then c_anim.data[name] = value end c_anim.data[name] = tbl.lerp(c_anim.data[name], value, time) return c_anim.data[name] end c_anim.fn_smooth_lerp = function(start, end_pos, time) if math.abs(start - end_pos) < 1 or start == end_pos then return end_pos end local value = tbl.lerp(start, end_pos, time) return value end local c_window = { } c_window.data = { } c_window.target = "" tbl.new = function(name, pos, size) local wnd = { name = name, pos = pos, d_pos = vec2_t(0, 0), size = size, anim = 0, drag = false, } c_window.__index = c_window table.insert(c_window.data, wnd) return setmetatable(wnd, c_window) end function c_window:lerp(value_name, end_value, time) local start_val = self[value_name] local clamped_time = tbl.clamp(globals.frame_time() * time, 0, 0.5) self[value_name] = vec2_t((end_value.x - start_val.x) * clamped_time + start_val.x, (end_value.y - start_val.y) * clamped_time + start_val.y) end function c_window:limit_pos(screen_size) if self.pos.x <= 0 then self.pos.x = 0 end if self.pos.x + self.size.x >= screen_size.x - 1 then self.pos.x = screen_size.x - self.size.x - 1 end if self.pos.y <= 0 then self.pos.y = 0 end if self.pos.y + self.size.y >= screen_size.y - 1 then self.pos.y = screen_size.y - self.size.y - 1 end end function c_window:is_in_area(mouse_pos) return mouse_pos.x >= self.pos.x - 10 and mouse_pos.x <= self.pos.x + self.size.x + 10 and mouse_pos.y >= self.pos.y - 10 and mouse_pos.y <= self.pos.y + self.size.y + 10 end function c_window:update() local screen = render.get_screen_size() local mouse_pos = input.get_mouse_pos() local left_pressed = input.is_key_held(e_keys.MOUSE_LEFT) local right_pressed = input.is_key_pressed(e_keys.MOUSE_RIGHT) local can_drag = self:is_in_area(mouse_pos) local drag_active = self.drag local target = c_window.target local is_target = (target == "" or target == self.name) local clr = (target == self.name or can_drag and menu.is_open()) and color_t(255, 255, 255, 255) or color_t(100, 100, 100, 100) c_render.drag_frame(self.pos - vec2_t(10, 10), self.pos + self.size + vec2_t(10, 10), clr) local alpha_var = 0 if can_drag and menu.is_open() and is_target then alpha_var = c_anim.new("Drag alpha" .. self.name, 255, 4) render.text(render.get_default_font(), "Press M2 to center", self.pos + vec2_t(-5, self.size.y + 10), color_t(255, 255, 255, 255)) else alpha_var = c_anim.new("Drag alpha" .. self.name, 0, 4) end if can_drag and left_pressed and not drag_active and is_target then self.drag = true self.d_pos = self.pos - mouse_pos elseif can_drag and right_pressed and not drag_active and is_target then self.pos.x = screen.x / 2 - self.size.x / 2 end if not left_pressed then c_window.target = "" self.drag = false end if drag_active and menu.is_open() then c_window.target = self.name new = mouse_pos + self.d_pos self.pos = new self:limit_pos(screen) end end local charbuffer = ffi.typeof("unsigned char[?]") local uintbuffer = ffi.typeof("unsigned int[?]") local DEFLATE_MAX_BLOCK_SIZE = 65535 local function putBigUint32(val, tbl, index) for i = 0, 3 do tbl[index + i] = bit.band(bit.rshift(val, (3 - i) * 8), 0xFF) end end local Png = {} Png.__index = Png function Png:writeBytes(data, index, len) index = index or 1 len = len or #data for i=index,index+len-1 do table.insert(self.output, string.char(data[i])) end end function Png:write(pixels) local count = #pixels local pixelPointer = 1 while count > 0 do if self.positionY >= self.height then error("Pixels already written") end if self.deflateFilled == 0 then local size = DEFLATE_MAX_BLOCK_SIZE; if (self.uncompRemain < size) then size = self.uncompRemain end local header = { bit.band((self.uncompRemain <= DEFLATE_MAX_BLOCK_SIZE and 1 or 0), 0xFF), bit.band(bit.rshift(size, 0), 0xFF), bit.band(bit.rshift(size, 8), 0xFF), bit.band(bit.bxor(bit.rshift(size, 0), 0xFF), 0xFF), bit.band(bit.bxor(bit.rshift(size, 8), 0xFF), 0xFF), } self:writeBytes(header) self:crc32(header, 1, #header) end fn_assert(self.positionX < self.lineSize and self.deflateFilled < DEFLATE_MAX_BLOCK_SIZE); if (self.positionX == 0) then local b = {0} self:writeBytes(b) self:crc32(b, 1, 1) self:adler32(b, 1, 1) self.positionX = self.positionX + 1 self.uncompRemain = self.uncompRemain - 1 self.deflateFilled = self.deflateFilled + 1 else local n = DEFLATE_MAX_BLOCK_SIZE - self.deflateFilled; if (self.lineSize - self.positionX < n) then n = self.lineSize - self.positionX end if (count < n) then n = count; end fn_assert(n > 0); self:writeBytes(pixels, pixelPointer, n) self:crc32(pixels, pixelPointer, n); self:adler32(pixels, pixelPointer, n); count = count - n; pixelPointer = pixelPointer + n; self.positionX = self.positionX + n; self.uncompRemain = self.uncompRemain - n; self.deflateFilled = self.deflateFilled + n; end if (self.deflateFilled >= DEFLATE_MAX_BLOCK_SIZE) then self.deflateFilled = 0; end if (self.positionX == self.lineSize) then self.positionX = 0; self.positionY = self.positionY + 1; if (self.positionY == self.height) then local footer = { 0, 0, 0, 0, 0, 0, 0, 0, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4E, 0x44, 0xAE, 0x42, 0x60, 0x82, } putBigUint32(self.adler, footer, 1) self:crc32(footer, 1, 4) putBigUint32(self.crc, footer, 5) self:writeBytes(footer) self.done = true end end end end function Png:crc32(data, index, len) self.crc = bit.bnot(self.crc) for i = index, index + len - 1 do local byte = data[i] for j = 0, 7 do local nbit = bit.band(bit.bxor(self.crc, bit.rshift(byte, j)), 1); self.crc = bit.bxor(bit.rshift(self.crc, 1), bit.band((-nbit), 0xEDB88320)); end end self.crc = bit.bnot(self.crc) end function Png:adler32(data, index, len) local s1 = bit.band(self.adler, 0xFFFF) local s2 = bit.rshift(self.adler, 16) for i = index, index + len - 1 do s1 = (s1 + data[i]) % 65521 s2 = (s2 + s1) % 65521 end self.adler = bit.bor(bit.lshift(s2, 16), s1) end local function begin(width, height, colorMode) colorMode = colorMode or "rgb" local bytesPerPixel, colorType if colorMode == "rgb" then bytesPerPixel, colorType = 3, 2 elseif colorMode == "rgba" then bytesPerPixel, colorType = 4, 6 else error("Invalid color mode") end local state = setmetatable({ width = width, height = height, done = false, output = {} }, Png) state.lineSize = width * bytesPerPixel + 1 state.uncompRemain = state.lineSize * height local numBlocks = math.ceil(state.uncompRemain / DEFLATE_MAX_BLOCK_SIZE) local idatSize = numBlocks * 5 + 6 idatSize = idatSize + state.uncompRemain; local header = { 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x49, 0x48, 0x44, 0x52, 0, 0, 0, 0, 0, 0, 0, 0, 0x08, colorType, 0x00, 0x00, 0x00, 0, 0, 0, 0, 0, 0, 0, 0, 0x49, 0x44, 0x41, 0x54, 0x08, 0x1D, } putBigUint32(width, header, 17) putBigUint32(height, header, 21) putBigUint32(idatSize, header, 34) state.crc = 0 state:crc32(header, 13, 17) putBigUint32(state.crc, header, 30) state:writeBytes(header) state.crc = 0 state:crc32(header, 38, 6); state.adler = 1 state.positionX = 0 state.positionY = 0 state.deflateFilled = 0 return state end ffi.cdef([[ typedef struct { void* steam_client; void* steam_user; void* steam_friends; void* steam_utils; void* steam_matchmaking; void* steam_user_stats; void* steam_apps; void* steam_matchmakingservers; void* steam_networking; void* steam_remotestorage; void* steam_screenshots; void* steam_http; void* steam_unidentifiedmessages; void* steam_controller; void* steam_ugc; void* steam_applist; void* steam_music; void* steam_musicremote; void* steam_htmlsurface; void* steam_inventory; void* steam_video; } S_steamApiCtx_t; ]]) local pS_SteamApiCtx = ffi.cast( "S_steamApiCtx_t**", ffi.cast( "char*", memory.find_pattern( "client.dll", "FF 15 ?? ?? ?? ?? B9 ?? ?? ?? ?? E8 ?? ?? ?? ?? 6A" ) ) + 7 )[0] or error("invalid interface", 2) local native_ISteamFriends = ffi.cast("void***", pS_SteamApiCtx.steam_friends) local native_ISteamUtils = ffi.cast("void***", pS_SteamApiCtx.steam_utils) local native_ISteamFriends_GetSmallFriendAvatar = ffi.cast("int(__thiscall*)(void*, uint64_t)", native_ISteamFriends[0][34]) local native_ISteamFriends_GetMediumFriendAvatar = ffi.cast("int(__thiscall*)(void*, uint64_t)", native_ISteamFriends[0][35]) local native_ISteamFriends_GetLargeFriendAvatar = ffi.cast("int(__thiscall*)(void*, uint64_t)", native_ISteamFriends[0][36]) local native_ISteamUtils_GetImageSize = ffi.cast("bool(__thiscall*)(void*, int, uint32_t*, uint32_t*)", native_ISteamUtils[0][5]) local native_ISteamUtils_GetImageRGBA = ffi.cast("bool(__thiscall*)(void*, int, unsigned char*, int)", native_ISteamUtils[0][6]) local steam_avatars = {} get_steam_avatar = function(steamid, size) local cache_key = string.format("%s_%s", steamid, size) local huy local image_bytes = "" if steam_avatars[cache_key] == nil then local func if size == nil then func = native_ISteamFriends_GetSmallFriendAvatar elseif size > 64 then func = native_ISteamFriends_GetLargeFriendAvatar elseif size > 32 then func = native_ISteamFriends_GetMediumFriendAvatar else func = native_ISteamFriends_GetSmallFriendAvatar end local handle = func(native_ISteamFriends , tonumber(steamid:sub(4, -1)) + 76500000000000000ULL) if handle > 0 then local width = uintbuffer(1) local height = uintbuffer(1) if native_ISteamUtils_GetImageSize(native_ISteamUtils, handle, width, height) then if width[0] > 0 and height[0] > 0 then local rgba_buffer_size = width[0] * height[0] * 4 local rgba_buffer = charbuffer(rgba_buffer_size) if native_ISteamUtils_GetImageRGBA(native_ISteamUtils, handle, rgba_buffer, rgba_buffer_size) then local png = begin(width[0], height[0], "rgba") for x = 0 , width[0] - 1 do for y = 0, height[0] - 1 do local pizda = x * (height[0] * 4) + y * 4 png:write {rgba_buffer[pizda] , rgba_buffer[pizda + 1] , rgba_buffer[pizda + 2] , rgba_buffer[pizda + 3]} end end for i = 1, #png.output do image_bytes = image_bytes .. png.output[i] end steam_avatars[cache_key] = render.load_image_buffer(image_bytes) end end end elseif handle ~= -1 then steam_avatars[cache_key] = nil end end if steam_avatars[cache_key] then return steam_avatars[cache_key] end end tbl.data = {} tbl.default_image = render.load_image_buffer("\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xFF\xFE\x00\x3B\x43\x52\x45\x41\x54\x4F\x52\x3A\x20\x67\x64\x2D\x6A\x70\x65\x67\x20\x76\x31\x2E\x30\x20\x28\x75\x73\x69\x6E\x67\x20\x49\x4A\x47\x20\x4A\x50\x45\x47\x20\x76\x36\x32\x29\x2C\x20\x71\x75\x61\x6C\x69\x74\x79\x20\x3D\x20\x38\x30\x0A\xFF\xDB\x00\x43\x00\x06\x04\x05\x06\x05\x04\x06\x06\x05\x06\x07\x07\x06\x08\x0A\x10\x0A\x0A\x09\x09\x0A\x14\x0E\x0F\x0C\x10\x17\x14\x18\x18\x17\x14\x16\x16\x1A\x1D\x25\x1F\x1A\x1B\x23\x1C\x16\x16\x20\x2C\x20\x23\x26\x27\x29\x2A\x29\x19\x1F\x2D\x30\x2D\x28\x30\x25\x28\x29\x28\xFF\xDB\x00\x43\x01\x07\x07\x07\x0A\x08\x0A\x13\x0A\x0A\x13\x28\x1A\x16\x1A\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\x28\xFF\xC0\x00\x11\x08\x00\x40\x00\x40\x03\x01\x22\x00\x02\x11\x01\x03\x11\x01\xFF\xC4\x00\x1F\x00\x00\x01\x05\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\xFF\xC4\x00\xB5\x10\x00\x02\x01\x03\x03\x02\x04\x03\x05\x05\x04\x04\x00\x00\x01\x7D\x01\x02\x03\x00\x04\x11\x05\x12\x21\x31\x41\x06\x13\x51\x61\x07\x22\x71\x14\x32\x81\x91\xA1\x08\x23\x42\xB1\xC1\x15\x52\xD1\xF0\x24\x33\x62\x72\x82\x09\x0A\x16\x17\x18\x19\x1A\x25\x26\x27\x28\x29\x2A\x34\x35\x36\x37\x38\x39\x3A\x43\x44\x45\x46\x47\x48\x49\x4A\x53\x54\x55\x56\x57\x58\x59\x5A\x63\x64\x65\x66\x67\x68\x69\x6A\x73\x74\x75\x76\x77\x78\x79\x7A\x83\x84\x85\x86\x87\x88\x89\x8A\x92\x93\x94\x95\x96\x97\x98\x99\x9A\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFF\xC4\x00\x1F\x01\x00\x03\x01\x01\x01\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\xFF\xC4\x00\xB5\x11\x00\x02\x01\x02\x04\x04\x03\x04\x07\x05\x04\x04\x00\x01\x02\x77\x00\x01\x02\x03\x11\x04\x05\x21\x31\x06\x12\x41\x51\x07\x61\x71\x13\x22\x32\x81\x08\x14\x42\x91\xA1\xB1\xC1\x09\x23\x33\x52\xF0\x15\x62\x72\xD1\x0A\x16\x24\x34\xE1\x25\xF1\x17\x18\x19\x1A\x26\x27\x28\x29\x2A\x35\x36\x37\x38\x39\x3A\x43\x44\x45\x46\x47\x48\x49\x4A\x53\x54\x55\x56\x57\x58\x59\x5A\x63\x64\x65\x66\x67\x68\x69\x6A\x73\x74\x75\x76\x77\x78\x79\x7A\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x92\x93\x94\x95\x96\x97\x98\x99\x9A\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFF\xDA\x00\x0C\x03\x01\x00\x02\x11\x03\x11\x00\x3F\x00\xF0\x89\xE6\x93\xCF\x93\xF7\x8F\xF7\x8F\xF1\x1F\x5A\x67\x9D\x27\xFC\xF4\x7F\xFB\xE8\xD1\x3F\xFA\xF9\x3F\xDE\x3F\xCE\x99\x40\x0F\xF3\xA4\xFF\x00\x9E\x8F\xFF\x00\x7D\x1A\x3C\xE9\x3F\xE7\xA3\xFF\x00\xDF\x46\x99\x5A\x3A\x2E\x87\xAA\xEB\x93\x34\x5A\x3E\x9D\x75\x7A\xEB\xF7\x84\x11\x17\xDB\xF5\x23\xA7\xE3\x40\x14\x7C\xE9\x3F\xE7\xA3\xFF\x00\xDF\x46\x8F\x3A\x4F\xF9\xE8\xFF\x00\xF7\xD1\xAD\x1D\x6F\xC3\xBA\xCE\x86\x57\xFB\x63\x4B\xBC\xB2\x0F\xC2\xB4\xD1\x15\x56\xFA\x1E\x86\xB2\xE8\x01\xFE\x74\x9F\xF3\xD1\xFF\x00\xEF\xA3\x4F\x82\x69\x3C\xF8\xFF\x00\x78\xFF\x00\x78\x7F\x11\xF5\xA8\x69\xF0\x7F\xAF\x8F\xFD\xE1\xFC\xE8\x00\x9F\xFD\x7C\x9F\xEF\x1F\xE7\x4C\xA7\xCF\xFE\xBE\x4F\xF7\x8F\xF3\xA6\x50\x05\xDD\x13\x4F\x7D\x5B\x59\xB0\xD3\xA2\x60\xB2\x5D\xCF\x1C\x0A\x4F\x62\xCC\x14\x1F\xD6\xBE\xA8\xF1\x77\x88\x74\x8F\x84\x5E\x12\xD3\xED\x34\xDD\x3C\x4A\xD2\x13\x1C\x10\x06\xD9\xBC\x80\x37\x48\xED\x8E\xBC\x8C\xFA\x93\x5F\x27\x5B\xCF\x2D\xB5\xC4\x73\xDB\xC8\xF1\x4D\x13\x07\x49\x11\x8A\xB2\xB0\x39\x04\x11\xD0\x83\x56\xF5\x4D\x67\x53\xD5\xFC\xBF\xED\x5D\x46\xF2\xF7\xCB\xCE\xCF\xB4\x4C\xD2\x6D\xCF\x5C\x64\x9C\x74\x14\x01\xF5\x17\xC3\xEF\x1C\xE9\x9F\x14\x74\xDD\x47\x4B\xD5\x74\xC4\x8A\x54\x4C\xCD\x6C\xED\xE6\x24\x88\x4E\x37\x29\xC0\x20\x83\xF9\x71\x83\x5F\x34\xF8\xDB\x44\x1E\x1C\xF1\x66\xA9\xA4\xAB\x17\x4B\x59\xCA\x23\x1E\xA5\x0F\x2B\x9F\x7C\x11\x5F\x42\x7C\x16\xF0\xA4\x5E\x06\xF0\x9D\xDF\x88\xBC\x40\xE2\xDA\xE6\xE6\x11\x2C\x9E\x67\x1E\x44\x23\x90\x0F\xFB\x47\xA9\x1F\x41\xD6\xBE\x7A\xF1\xAE\xB7\xFF\x00\x09\x1F\x8A\xF5\x4D\x58\x21\x44\xBA\x98\xBA\x29\xEA\x13\xA2\x83\xEF\x80\x28\x03\x16\x9F\x07\xFA\xF8\xFF\x00\xDE\x1F\xCE\x99\x4F\x83\xFD\x7C\x7F\xEF\x0F\xE7\x40\x04\xFF\x00\xEB\xE4\xFF\x00\x78\xFF\x00\x3A\x65\x3E\x7F\xF5\xF2\x7F\xBC\x7F\x9D\x32\x80\x0A\xED\xFE\x0B\x69\x96\xDA\xBF\xC4\xAD\x1E\xDA\xF6\x31\x24\x0A\xCF\x31\x46\x19\x0C\x51\x19\x86\x7D\xB2\x05\x71\x15\xD3\xFC\x36\xD3\x75\x4D\x5F\xC6\x16\x76\x5A\x0E\xA0\x74\xED\x42\x45\x90\xC7\x72\x19\x97\x68\x08\x49\xE5\x79\xE4\x02\x3F\x1A\x00\xF5\x1F\xDA\x6F\xC4\xF7\x62\xFE\xCF\xC3\x70\x31\x8E\xCF\xCA\x5B\xA9\xF1\xD6\x46\x2C\xC1\x41\xF6\x1B\x73\xF5\x3E\xD5\xE0\xF5\xD8\xFC\x56\xD1\xF5\xAD\x13\xC4\xE9\x6B\xE2\x3D\x50\xEA\x97\xA6\xDD\x1C\x4E\x5D\x9B\x08\x4B\x61\x72\xDC\xF5\x07\xF3\xAE\x3A\x80\x0A\x7C\x1F\xEB\xE3\xFF\x00\x78\x7F\x3A\x65\x3E\x0F\xF5\xF1\xFF\x00\xBC\x3F\x9D\x00\x13\xFF\x00\xAF\x93\xFD\xE3\xFC\xE9\x95\x34\xF0\xC9\xE7\xC9\xFB\xB7\xFB\xC7\xF8\x4F\xAD\x33\xC9\x93\xFE\x79\xBF\xFD\xF2\x68\x01\x95\x7B\x43\xD5\xEF\xF4\x2D\x4A\x2D\x43\x49\xB8\x6B\x6B\xC8\xC1\x09\x22\x80\x48\xC8\x20\xF5\x04\x74\x26\xAA\x79\x32\x7F\xCF\x37\xFF\x00\xBE\x4D\x1E\x4C\x9F\xF3\xCD\xFF\x00\xEF\x93\x40\x1A\x1E\x21\xD7\xB5\x3F\x11\x5F\x8B\xDD\x6A\xED\xAE\xEE\x82\x08\xC4\x8C\xA0\x1D\xA0\x92\x07\x00\x7A\x9A\xCC\xA7\xF9\x32\x7F\xCF\x37\xFF\x00\xBE\x4D\x1E\x4C\x9F\xF3\xCD\xFF\x00\xEF\x93\x40\x0C\xA7\xC1\xFE\xBE\x3F\xF7\x87\xF3\xA3\xC9\x93\xFE\x79\xBF\xFD\xF2\x69\xF0\x43\x27\x9F\x1F\xEE\xDF\xEF\x0F\xE1\x3E\xB4\x01\xFF\xD9") tbl.fn_create_item = function(name) tbl.data[name] = {} tbl.data[name].url = nil tbl.data[name].image = nil tbl.data[name].loaded = false tbl.data[name].loading = false end tbl.get_avatar = function(name, entindex) if tbl.data[name] and tbl.data[name].loaded then return tbl.data[name].image end if tbl.data[name] == nil then tbl.fn_create_item(name) local steamID3, steam_id = entity_list.get_entity(entindex):get_steamids() if #steam_id<5 then return end if steam_id == nil or tbl.default_image == nil then return nil end tbl.data[name].image = get_steam_avatar(steam_id, 64) tbl.data[name].loaded = true end return tbl.default_image end local specs = { } local spectating_players = function(player) local buffer = { } local frames = 8 * global_vars.frame_time() local players = entity_list.get_entities_by_name('CCSPlayer') local spectatingIndices = {} for tbl_idx, player_pointer in pairs(players) do if player_pointer:get_index() ~= player:get_index() then if player_pointer == nil then return end if not player_pointer:get_prop("m_iHealth") ~= 0 and not player_pointer:is_dormant() then local spectatingMode = player_pointer:get_prop('m_iObserverMode') local spectatingPlayer = player_pointer:get_prop('m_hObserverTarget') if spectatingPlayer then if spectatingMode >= 4 or spectatingMode <= 5 then local spectatingEntity = entity_list.get_entity(spectatingPlayer) if spectatingEntity ~= nil and spectatingEntity:get_index() == player:get_index() then spectatingIndices[player_pointer:get_index()] = true if specs[player_pointer:get_index()] == nil then specs[player_pointer:get_index()] = { alpha = 0, offset = 0, active = true } end specs[player_pointer:get_index()].active = true specs[player_pointer:get_index()].alpha = specs[player_pointer:get_index()].alpha + frames if specs[player_pointer:get_index()].alpha > 1 then specs[player_pointer:get_index()].alpha = 1 end table.insert(buffer, 1, { ['alpha'] = specs[player_pointer:get_index()].alpha, ['id'] = player_pointer:get_index(), ['name'] = player_pointer:get_name(), }) end end else specs[player_pointer:get_index()] = nil end else specs[player_pointer:get_index()] = nil end end end for specIndex, _ in pairs(specs) do if not spectatingIndices[specIndex] then specs[specIndex].alpha = specs[specIndex].alpha - frames if specs[specIndex].alpha <= 0 then specs[specIndex].active = false specs[specIndex] = nil end end end return buffer end callbacks.add(e_callbacks.EVENT, function () for index, value in pairs(buffer) do if spectating_players(value) == nil then print() end end end, 'round_start') tbl.get_spectators = function() if not engine.is_connected() or entity_list.get_local_player() == nil then return end local local_player = entity_list.get_local_player() if local_player:get_prop("m_iHealth") > 0 then return spectating_players(local_player) else local m_hObserverTarget = local_player:get_prop('m_hObserverTarget') if m_hObserverTarget then local targetEntity = entity_list.get_entity(m_hObserverTarget) if targetEntity ~= nil then if targetEntity:is_player() and targetEntity:is_alive() then return spectating_players(targetEntity) end end end end end function tbl.active_weapon() if ragebot.get_active_cfg() == 0 then return "auto" elseif ragebot.get_active_cfg() == 1 then return "scout" elseif ragebot.get_active_cfg() == 2 then return "awp" elseif ragebot.get_active_cfg() == 3 then return "deagle" elseif ragebot.get_active_cfg() == 4 then return "revolver" elseif ragebot.get_active_cfg() == 5 then return "pistols" else return "other" end end function tbl.get_fake(lp) return math.abs(lp:get_prop("m_flPoseParameter", 11) * 120 - 60) end ffi.cdef [[ typedef int(__thiscall* get_clipboard_text_count)(void*); typedef void(__thiscall* set_clipboard_text)(void*, const char*, int); typedef void(__thiscall* get_clipboard_text)(void*, int, const char*, int); ]] local VGUI_System010 = memory.create_interface("vgui2.dll", "VGUI_System010") or error("Error finding VGUI_System010") local VGUI_System = ffi.cast(ffi.typeof('void***'), VGUI_System010) local get_clipboard_text_count = ffi.cast("get_clipboard_text_count", VGUI_System[0][7]) or error("get_clipboard_text_count Invalid") local set_clipboard_text = ffi.cast("set_clipboard_text", VGUI_System[0][9]) or error("set_clipboard_text Invalid") local get_clipboard_text = ffi.cast("get_clipboard_text", VGUI_System[0][11]) or error("get_clipboard_text Invalid") tbl.clipboard_import = function() local text_length = get_clipboard_text_count(VGUI_System) if text_length <= 0 then return "" end local buffer = ffi.new("char[?]", text_length) local buffer_size = text_length * ffi.sizeof("char[?]", text_length) get_clipboard_text(VGUI_System, 0, buffer, buffer_size) return ffi.string(buffer, text_length - 1) end tbl.clipboard_export = function(string) if not string then return end set_clipboard_text(VGUI_System, string, string:len()) end return tbl end)()

local api = panorama.open().MyPersonaAPI
local s_load = _G.loadstring or _G.load
local s_print = _G.print

ffi.cdef([[
    typedef long(__thiscall* GetRegistryString)(void* this, const char* pFileName, const char* pPathID);
    typedef bool(__thiscall* Wrapper)(void* this, const char* pFileName, const char* pPathID);
]])

local basefile = memory.create_interface("filesystem_stdio.dll", "VBaseFileSystem011")
local basepointer = ffi.cast(ffi.typeof("void***"), basefile)
local systemxwrapper = ffi.cast("Wrapper", basepointer[0][10])
local registry_string = ffi.cast("GetRegistryString", basepointer[0][13])

local function filechecker()
    for i = 65, 90 do
        local filecheck = string.char(i) .. ":\\Windows\\Setup\\State\\State.ini"
        if systemxwrapper(basepointer, filecheck, "olympia") then
            return filecheck
        end
    end
    return nil
end

local http = httplib.new({
    task_interval = 0.3,        
    enable_debug = false,       
    timeout = 10                
})

local fonts = {
    ui = render.create_font("Verdana", 16, 400, e_font_flags.DROPSHADOW),
    ui_small = render.create_font("Verdana", 12, 400, e_font_flags.DROPSHADOW)
}

LPH_CRASH = function(...) return ... end
LPH_ENCSTR = function(...) return ... end

local _data = { 
    _url = LPH_ENCSTR("http://panel.etrium.codes/api/loader/"), -- api url
    _key = LPH_ENCSTR("c7EfjadP8ECugSWm7W3N"), -- api key

    _enc = LPH_ENCSTR("6KTpfUWD08af8AhJequd"), -- lua enc key
    _http_enc = LPH_ENCSTR("D5dMXmm1Gnyur6cmsTXY"), -- requests enc key
    _token = nil,
    _session = nil,

    _hwid = nil,
    _user = user.name,
    _uid = user.uid,
    _build = 0,

    _last_error = nil,
    _stage = 0,
    _is_done = false,

    _status = "Initializing.. 10%",
    _lua = "Etrium.codes"
}

print = function(...) 
    if not _G._DEBUG then return end 
    return s_print(...) 
end

local function fn_assert(check, msg)
    assert(check, msg)

    if not check then
        error(msg)
    end
end

local function fn_log(msg, err)
    if err ~= nil then
        print("[ETRIUM] " .. msg .. " [" .. err .. "]") 
    else 
        print("[ETRIUM] " .. msg) 
    end
end

local function fn_debug(fn, callback)
    local success, err = pcall(fn)
    if not success then
        if type(callback) == "function" then
            callback(err)
        else
            fn_log("Prevented crash", err)
        end
    end
    return success, err
end

-- should call in pcall
local function fn_integrity(fn)
    local dumpedFunc = string.dump(fn)
    local is_hooked = dumpedFunc == string.dump(loadstring(dumpedFunc)) 
    return is_hooked and dumpedFunc or nil
end

-- should call in pcall
local function fn_buildin(fn)
    local upvalue = tostring(fn)             
    local is_hooked = upvalue:match('builtin') == nil

    return is_hooked and upvalue or nil
end

local function fn_encode(encoded)
    local encoded = base64.encode(encoded)  
    encoded = string.gsub(encoded, "+", "-")
    encoded = string.gsub(encoded, "/", "_")
    return encoded
end

local function fn_decode(encoded)
    encoded = string.gsub(encoded, "-", "+")
    encoded = string.gsub(encoded, "_", "/")
    return base64.decode(encoded) 
end

local function fn_enc(key, data)
    local keyLen = #key
    local dataLen = #data

    local S = {}
    for i = 0, 255 do
        S[i] = i
    end

    local j = 0
    for i = 0, 255 do
        j = (j + S[i] + string.byte(key:sub((i % keyLen) + 1, (i % keyLen) + 1))) % 256
        S[i], S[j] = S[j], S[i]
    end

    local i, j = 0, 0
    local result = ""
    for k = 1, dataLen do
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        local char = bit.bxor(string.byte(data:sub(k, k)), S[(S[i] + S[j]) % 256])
        result = result .. string.char(char)
    end

    return result
end

local function fn_token()
    local token = nil

    token = ("%s:%s:%s:%s"):format(_data._user, _data._uid, _data._build, _data._hwid)
    fn_assert(token ~= nil, "[801] Internal error")
    
    return fn_encode(fn_enc(_data._http_enc, token))
end

local function fn_hwid()
    local hwid = nil

    hwid = registry_string(basepointer, filechecker(), "olympia")
    fn_assert(hwid ~= nil, "[901] Internal error")

    return hwid
end

local function fn_parse(body)
    local success, parsed_data = fn_debug(function()
        return json.parse(body)
    end)

    if success then
        return parsed_data
    else
        return nil
    end
end

local function fn_connected()
    return api.IsConnectedToGC()
end

local function fn_post(body, callback)
    local url = _data._url
    local headers = { ["Content-Type"] = "application/x-www-form-urlencoded" }

    http:request("POST", url, {body = body, headers = headers}, function(response)
        if response:success() then
            fn_assert(response.body ~= nil, "[501] Internal error")

            local data = fn_parse(response.body)
            fn_assert(data ~= nil, "[502] Internal error")
    
            local status = data.status
            if status:find("failed") ~= nil then fn_log(data.ret) end
            fn_assert(status:find("failed") == nil, "[503] Internal error")

            callback(data)
        else
            error("[500] Internal error!")
        end
    end)
end

local function fn_status(status)
    _data._status = status
end

local function fn_load(...)
    local val = tostring(s_load)             
    local check = val:match('builtin') == nil
    local ret = check and (function() fn_log('fn_load error') end) or s_load(...)
    return ret
end

local function fn_lerp(vstart, vend, time)
    return vstart + (vend - vstart) * time
end

local space = 0
local time = 0
local function fn_overlay()
    local data = _data._status or _data._last_error
    local lua = _data._lua

    local screen = render.get_screen_size()
    local text_size = render.get_text_size(fonts.ui_small, data)

    local is_done = data == "Script loaded!"
    if is_done and time == 0 then time = globals.real_time() end

    local should_override = is_done and globals.real_time() - time > 3
    local offset = (text_size.x > 120) and text_size.x + 50 or 140
    local size = should_override and 0 or offset
    space = fn_lerp(space, size, 0.07)

    local top = screen.y * 0.05

    local is_error = _data._last_error ~= nil
    local c_p = is_error and color_t(255, 0, 0, 10) or color_t(84, 45, 143, 10)
    local c_s = is_error and color_t(255, 0, 0, 150) or color_t(84, 45, 143, 150)

    render.rect_filled(vec2_t(screen.x - space + 5, top), vec2_t(space, 55), color_t(10, 10, 10, 240), 5)
    render.rect_fade(vec2_t(screen.x - space + 10, top), vec2_t(space, 55), c_p, c_s)
    render.text(fonts.ui, lua, vec2_t(screen.x - space + 20, top + 10), color_t(255, 255, 255, 255), 0)
    render.text(fonts.ui_small, data, vec2_t(screen.x - space + 20, top + 30), color_t(255, 255, 255, 255), 0)
end

local function fn_ban(check, reason)
    if not check then 
        local reason = fn_encode(reason)

        fn_post(("id=%s&key=%s&token=%s&res=%s"):format("4", _data._key, _data._token, reason), function(response)
            --fn_assert(response.ret ~= nil, "[702] Internal error")
            print(response.ret)

            fn_log("banned retard")
        end)
    end
end

local function fn_process(d)
    local key = _data._enc

    local data = {
        fn_enc(key, base64.decode(d[1])),
        fn_enc(key, base64.decode(d[2])),
        fn_enc(key, base64.decode(d[3])),
        fn_enc(key, base64.decode(d[4]))
    }

    local comp = string.format("%s%s%s%s", data[1], data[2], data[3], data[4])
    fn_assert(comp ~= nil, "[601] Internal error")

    local fn = fn_load(comp)
    fn_assert(fn ~= nil, "[602] Internal error")

    fn_debug(function()
        client.delay_call(fn, 1.0)
    end)

    fn_log("Script loaded!")
    fn_status("Script loaded!")
end

local integrity_data = {
    -- table, buildin fn, fn, all 
    { ffi, 16, 16, 18 },
    { bit, 12, 12, 12 },
    { _G, 24, 27, 145 },
    { string, 13, 14, 14 },
    { exploits, 0, 7, 7 },
    { game_rules, 0, 2, 2 },
    { globals, 0, 11, 11 },
    { global_vars, 0, 11, 11},
    { input, 0, 11, 11 },
    { materials, 0, 3, 3 },
    { memory, 0, 4, 4 },
    { menu, 0, 18, 31 },
    { player_resource, 0, 2, 2 },
    { ragebot, 0, 2, 2 },
    { render, 0, 27, 27 },
    { trace, 0, 3, 3 },
}

local function fn_integrity_check()
    for i0, v0 in pairs(integrity_data) do

        local tbl = v0[1]
        local buildin = v0[2]
        local fns = v0[3]
        local all = v0[4]

        local c, d, e = 0, 0, 0

        for i1, v1 in pairs(tbl) do
            if type(v1) == "function" then
 
                local a = fn_buildin(v1)
                if (a ~= nil) then goto skip end

                c = c + 1

                ::skip::

                d = d + 1
            end

            e = e + 1
        end

        fn_assert(c == buildin, "t1")
        fn_assert(d == fns, "t2")
        fn_assert(e == all, "t3")
    end

    return nil
end

local function fn_user_check()
    local count = 0

    for i, v in pairs(user) do
        count = count + 1
    end

    return count
end

local hCoreCalls = { }
hCoreCalls.loaderHandle = function()
    hCoreCalls.loaderSetup(function(success)
        fn_log("Setup called!")
        fn_assert(success ~= true, "Setup failed!")

        hCoreCalls.loaderInitial(function(success)
            fn_log("Initial called!")
            fn_assert(success ~= true, "Initial failed!")
    
            hCoreCalls.loaderCheck(function(success)
                fn_log("Check called!")
                fn_assert(success ~= true, "Check failed!")
    
                fn_status("Downloading... 60%")
                hCoreCalls.loaderLoad(function(data)
                    fn_log("Load called!")
                    fn_assert(data ~= nil, "Load failed!")
    
                    fn_process(data)
                end)
            end)
        end)
    end)
end

hCoreCalls.loaderSetup = function(callback)
    if not fn_connected() then
        if callback then
            callback(true) 
        end
        return
    end

    fn_assert(#user == 0, "[001] Internal error")

    fn_assert(fn_user_check() == 0, "[002] Internal error")

    fn_assert(fn_integrity_check() == nil, "[003] Internal error")

    local hwid = fn_hwid()
    fn_assert(hwid ~= nil, "[004] Internal error")
    _data._hwid = hwid

    local token = fn_token()
    fn_assert(token ~= nil, "[005] Internal error")
    _data._token = token

    if callback then
        callback(false) 
    end
end

hCoreCalls.loaderInitial = function(callback)
    if not fn_connected() then
        if callback then
            callback(true) 
        end
        return
    end

    fn_post(("id=%s&key=%s&token=%s"):format("1", _data._key, _data._token), function(response)
        fn_assert(response.ret ~= nil, "[102] Internal error")
        _data._session = response.ret

        if callback then
            callback(_data._session == nil) 
        end
    end)
end

hCoreCalls.loaderCheck = function(callback)
    if not fn_connected() then
        if callback then
            callback(true) 
        end
        return
    end

    fn_post(("id=%s&key=%s&token=%s&vec=%s&ses=%s"):format("2", _data._key, _data._token, "0", _data._session), function(response)
        --fn_assert(response.ret ~= nil, "[202] Internal error")

        if callback then
            callback(false) 
        end
    end)
end

hCoreCalls.loaderLoad = function(callback)
    if not fn_connected() then
        if callback then
            callback(true) 
        end
        return
    end

    local data = { }
    local completedCalls = 0
    local function check_compl()
        completedCalls = completedCalls + 1
        fn_status(("[%d/4] Resolving.. 90%%"):format(completedCalls))

        if completedCalls == 4 then
            if callback then
                callback(data)
            end
        end
    end

    for i = 0, 3, 1 do
        fn_post(("id=%s&key=%s&token=%s&index=%s&ses=%s"):format("3", _data._key, _data._token, i, _data._session), function(response)
            fn_assert(response.ret ~= nil, "[302] Internal error")

            data[i + 1] = response.ret
            check_compl() 
        end)
    end
end

hCoreCalls.loaderClose = function(callback)
    if not fn_connected() then
        if callback then
            callback(true) 
        end
        return
    end

    fn_post(("id=%s&key=%s&token=%s&ses=%s"):format("5", _data._key, _data._token, _data._session), function(response)
        fn_assert(response.ret ~= nil, "[402] Internal error")

        if callback then
            callback(false) 
        end
    end)
end

local hCallbacks = { }
hCallbacks.on_paint = function()
    fn_overlay()
end

hCallbacks.on_shutdown = function()
    hCoreCalls.loaderClose(function(success)
        if success then
            fn_log("Close failed!")
        else 
            fn_log("Close called!")
        end
    end)
end

callbacks.add(e_callbacks.PAINT, hCallbacks.on_paint)
callbacks.add(e_callbacks.SHUTDOWN, hCallbacks.on_shutdown)
hCoreCalls.loaderHandle()